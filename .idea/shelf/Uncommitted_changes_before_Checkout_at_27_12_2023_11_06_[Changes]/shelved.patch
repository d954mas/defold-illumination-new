Index: illumination/native/include/lights.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef illumination_lights_h\r\n#define illumination_lights_h\r\n\r\n#include <dmsdk/sdk.h>\r\n#include \"utils.h\"\r\n#include \"frustum_cull.h\"\r\n#include <cmath> // For sqrt, log2, and pow functions\r\n#include <sstream>  // For std::ostringstream\r\n#include <string>   // For std::string\r\n#include <cstring>  // For std::strcpy\r\n\r\n\r\n#define LIGHT_META \"IlluminationLights.Light\"\r\n#define LIGHT_PIXELS 6 // pixels per light\r\n#define LIGHT_RADIUS_MAX 64.0 // store in r value of pixel. Mb store as rgba value for better precision?\r\n\r\n#define LIGHT_MIN_POSITION_X -511\r\n#define LIGHT_MAX_POSITION_X 512\r\n#define LIGHT_MIN_POSITION_Y -511\r\n#define LIGHT_MAX_POSITION_Y 512\r\n#define LIGHT_MIN_POSITION_Z -511\r\n#define LIGHT_MAX_POSITION_Z 512\r\n#define LIGHT_AXIS_CAPACITY 1024 //[-511 512]\r\n#define M_PI  3.14159265358979323846  /* pi */\r\n\r\n\r\n\r\n\r\n\r\nnamespace IlluminationLights {\r\n\r\n//region TEXTURE\r\nstatic const dmhash_t HASH_RGBA = dmHashString64(\"rgba\");\r\nstatic const dmhash_t HASH_EMPTY = dmHashString64(\"empty\");\r\nstatic const dmBuffer::StreamDeclaration rgba_buffer_decl[] = {\r\n    {HASH_RGBA, dmBuffer::VALUE_TYPE_UINT8, 4},\r\n};\r\n\r\n\r\n// Function to find the smallest power of two greater than or equal to n\r\nint SmallestPowerOfTwo(int n) {\r\n    if (n <= 0) return 1;\r\n\r\n    int logVal = (int)std::ceil(std::log2(n));\r\n    return (int)std::pow(2, logVal);\r\n}\r\n\r\n// Function to find the width and height for the texture\r\nvoid FindTextureDimensions(int totalPixels, int& width, int& height) {\r\n    if (totalPixels <= 0) {\r\n        width = height = 1;\r\n        return;\r\n    }\r\n\r\n    // Start with a square texture estimate\r\n    int sqrtPixels = (int)std::sqrt(totalPixels);\r\n    int initialDimension = SmallestPowerOfTwo(sqrtPixels);\r\n\r\n    width = initialDimension;\r\n    height = initialDimension;\r\n\r\n    //check if one side can be smaller. Texture can be not square\r\n    if (width * (height / 2) >= totalPixels) {\r\n        height /= 2;\r\n    }\r\n}\r\n//endregion\r\n\r\ninline float Fract(float f){\r\n    return f - floor(f);\r\n}\r\n\r\n//encode from [0;1)\r\ninline dmVMath::Vector4 EncodeFloatRGBA(float v, float min, float max){\r\n    //if (v<MIN_BORDER){MIN_BORDER = v;}\r\n    //if (v>MAX_BORDER){MAX_BORDER = v;}\r\n    assert(v>=min);\r\n    assert(v<max);\r\n    assert(max>min);\r\n    v = (v- min)/(max-min);\r\n\r\n    dmVMath::Vector4 enc = dmVMath::Vector4(1.0, 255.0, 65025.0, 16581375.0) * v;\r\n    enc.setX(Fract(enc.getX()));\r\n    enc.setY(Fract(enc.getY()));\r\n    enc.setZ(Fract(enc.getZ()));\r\n    enc.setW(Fract(enc.getW()));\r\n\r\n    return enc;\r\n}\r\n\r\n\r\n\r\nstruct Light {\r\n    int index;\r\n    uint8_t encodedIndex[4];\r\n    bool enabled;\r\n    dmVMath::Vector3 position;\r\n    dmVMath::Vector3 direction;\r\n    dmVMath::Vector4 color; //r,g,b brightness\r\n    float radius;\r\n    float smoothness;\r\n    float specular;\r\n    float cutoff;\r\n    float aabb[6];\r\n    bool dirty;\r\n};\r\n\r\n//not lightuserdata type it base userdata\r\n//user data for Light object\r\nstruct LuaLightUserData {\r\n    Light* light;\r\n    bool valid; //make userdata invalid when user delete light\r\n};\r\n\r\nstruct LightCluster {\r\n    int numLights;\r\n    uint8_t* clusterStart;\r\n    uint8_t* currentLightStart;\r\n};\r\n\r\n\r\n\r\n//region Light\r\ninline void LightUpdateAABB(Light* light){\r\n    float radius = light->radius;\r\n    float x = light->position.getX();\r\n    float y = light->position.getY();\r\n    float z = light->position.getZ();\r\n    light->aabb[0] = x - radius;\r\n    light->aabb[1] = y - radius;\r\n    light->aabb[2] = z - radius;\r\n    light->aabb[3] = x + radius;\r\n    light->aabb[4] = y + radius;\r\n    light->aabb[5] = z + radius;\r\n}\r\n\r\n//region Light\r\ninline void LightReset(Light* light){\r\n    light->position = dmVMath::Vector3(0.0f, 0.0f, 0.0f);\r\n    light->direction = dmVMath::Vector3(0.0f, 0.0f, -1.0f);\r\n    light->color = dmVMath::Vector4(1.0f, 1.0f, 1.0f, 1.0f);\r\n    light->radius = 1.0f;\r\n    light->smoothness = 1.0f;\r\n    light->specular = 0.5f;\r\n    light->cutoff = 1.0f;\r\n    light->dirty = true;\r\n    LightUpdateAABB(light);\r\n}\r\n\r\n//region Light\r\ninline void LightSetPosition(Light* light, float x, float y, float z) {\r\n    if (x < LIGHT_MIN_POSITION_X || x > LIGHT_MAX_POSITION_X) {\r\n      dmLogWarning(\"Light X position out of bounds. Clamping to [%f, %f].\", LIGHT_MIN_POSITION_X, LIGHT_MAX_POSITION_X);\r\n      x = fmax(LIGHT_MIN_POSITION_X, fmin(x, LIGHT_MAX_POSITION_X));\r\n    }\r\n\r\n    if (y < LIGHT_MIN_POSITION_Y || y > LIGHT_MAX_POSITION_Y) {\r\n      dmLogWarning(\"Light Y position out of bounds. Clamping to [%f, %f].\", LIGHT_MIN_POSITION_Y, LIGHT_MAX_POSITION_Y);\r\n      y = fmax(LIGHT_MIN_POSITION_Y, fmin(y, LIGHT_MAX_POSITION_Y));\r\n    }\r\n\r\n    if (z < LIGHT_MIN_POSITION_Z || z > LIGHT_MAX_POSITION_Z) {\r\n      dmLogWarning(\"Light Z position out of bounds. Clamping to [%f, %f].\", LIGHT_MIN_POSITION_Z, LIGHT_MAX_POSITION_Z);\r\n      z = fmax(LIGHT_MIN_POSITION_Z, fmin(z, LIGHT_MAX_POSITION_Z));\r\n    }\r\n\r\n\r\n    if (light->position.getX()!=x || light->position.getY()!=y || light->position.getZ()!=z) {\r\n        light->position = dmVMath::Vector3(x,y,z);\r\n        LightUpdateAABB(light);\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetDirection(Light* light, float x, float y, float z) {\r\n    dmVMath::Vector3 newDir = Vectormath::Aos::normalize(dmVMath::Vector3(x, y, z));\r\n    if (light->direction.getX() != newDir.getX() || light->direction.getY() != newDir.getY() || light->direction.getZ() != newDir.getZ()) {\r\n        light->direction = newDir;\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetColor(Light* light, float r, float g, float b, float brightness) {\r\n    if (light->color.getX() != r || light->color.getY() != g || light->color.getZ() != b || light->color.getW() != brightness) {\r\n        light->color = dmVMath::Vector4(r, g, b, brightness);\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetRadius(Light* light, float newRadius) {\r\n    if (newRadius < 0.0f || newRadius > LIGHT_RADIUS_MAX) {\r\n        dmLogWarning(\"Light radius out of bounds. Clamping to [0, %d].\", LIGHT_RADIUS_MAX);\r\n        newRadius = fmax(0.0f, fmin(newRadius, (float)LIGHT_RADIUS_MAX));\r\n    }\r\n\r\n    if (light->radius != newRadius) {\r\n        light->radius = newRadius;\r\n        LightUpdateAABB(light);\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetSmoothness(Light* light, float newSmoothness) {\r\n    newSmoothness = fmax(0.0f, fmin(newSmoothness, 1.0f));\r\n    if (light->smoothness != newSmoothness) {\r\n        light->smoothness = newSmoothness;\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetCutoff(Light* light, float newCutoff) {\r\n    newCutoff = fmax(0.0f, fmin(newCutoff, 1.0f));\r\n    if (light->cutoff != newCutoff) {\r\n        light->cutoff = newCutoff;\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetSpecular(Light* light, float newSpecular) {\r\n    newSpecular = fmax(0.0f, fmin(newSpecular, 1.0f));\r\n    if (light->specular != newSpecular) {\r\n        light->specular = newSpecular;\r\n        light->dirty = true;\r\n    }\r\n}\r\n\r\ninline void LightSetEnabled(Light* light, bool enabled) {\r\n    light->enabled = enabled;\r\n}\r\n\r\ninline bool LightIsAddLightToScene(Light* light) {\r\n\treturn light->enabled && light->color.getW() > 0.0f;\r\n}\r\n\r\ninline void LightWriteToBuffer(Light* light, uint8_t* values,  uint32_t stride) {\r\n    dmVMath::Vector4 posX = EncodeFloatRGBA(light->position.getX(),LIGHT_MIN_POSITION_X,LIGHT_MAX_POSITION_X+1)*255;\r\n    values[0] = posX.getX();values[1] = posX.getY();values[2] = posX.getZ();values[3] = posX.getW();\r\n    values+=stride;\r\n\r\n    //dmLogInfo(\"light:%d x:%f y:%f z:%f\",light->index,light->position.getX(),light->position.getY(),light->position.getZ());\r\n\r\n    dmVMath::Vector4 posY = EncodeFloatRGBA(light->position.getY(),LIGHT_MIN_POSITION_Y,LIGHT_MAX_POSITION_Y+1)*255;\r\n    values[0] = posY.getX();values[1] = posY.getY();values[2] = posY.getZ();values[3] = posY.getW();\r\n    values+=stride;\r\n\r\n    dmVMath::Vector4 posZ = EncodeFloatRGBA(light->position.getZ(),LIGHT_MIN_POSITION_Z,LIGHT_MAX_POSITION_Z+1)*255;\r\n    values[0] = posZ.getX();values[1] = posZ.getY();values[2] = posZ.getZ();values[3] = posZ.getW();\r\n    values+=stride;\r\n\r\n    values[0] = (light->direction.getX() + 1)/2*255;\r\n    values[1] = (light->direction.getY() + 1)/2*255;\r\n    values[2] = (light->direction.getZ() + 1)/2*255;\r\n    // values[3] = 0 //empty field\r\n    values+=stride;\r\n\r\n    values[0] = light->color.getX()*255;\r\n    values[1] = light->color.getY()*255;\r\n    values[2] = light->color.getZ()*255;\r\n    values[3] = light->color.getW()*255;\r\n    values+=stride;\r\n\r\n\r\n    values[0] = light->radius / LIGHT_RADIUS_MAX * 255;\r\n    values[1] = light->smoothness * 255;\r\n    values[2] = light->specular * 255;\r\n    values[3] = light->cutoff < 1 ? (cos(light->cutoff * M_PI) + 1) / 2 * 255 : 255;\r\n    values+=stride;\r\n}\r\n//endregion\r\n\r\n//region light Lua\r\n\r\ninline LuaLightUserData* LightUserdataCheck(lua_State* L, int index){\r\n    LuaLightUserData* userData = (LuaLightUserData*)luaL_checkudata(L, index, LIGHT_META);\r\n     if (!userData->valid) {luaL_error(L,\"Light userdata not valid\");}\r\n     return userData;\r\n}\r\n\r\nstatic int LuaLightToString(lua_State* L) {\r\n    LuaLightUserData* userData = (LuaLightUserData*)luaL_checkudata(L, 1, LIGHT_META);\r\n    if (!userData->valid) {\r\n        lua_pushfstring(L, \"Light[%d]. Invalid userdata\",userData->light->index);\r\n        return 1;\r\n    }\r\n\r\n    Light* light = userData->light;\r\n\r\n    lua_pushfstring(L, \"Light[%d]: Position(%.2f, %.2f, %.2f)\",\r\n                    light->index,\r\n                    light->position.getX(),\r\n                    light->position.getY(),\r\n                    light->position.getZ());\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightUserdataGC(lua_State* L) {\r\n    LuaLightUserData* userData = (LuaLightUserData*)lua_touserdata(L, 1);\r\n    if(userData->valid){\r\n        dmLogError(\"Light[%d] memory leak. Userdata was garbage collected without illumination_lights.light_destroy(light)\",userData->light->index);\r\n    }\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightSetPosition(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 4);\r\n    LuaLightUserData* userData = LightUserdataCheck(L,1);\r\n    LightSetPosition(userData->light,\r\n                     luaL_checknumber(L, 2),\r\n                     luaL_checknumber(L, 3),\r\n                     luaL_checknumber(L, 4));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetPosition(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L,1);\r\n    Vectormath::Aos::Vector3 *out = dmScript::CheckVector3(L, 2);\r\n    *out = userData->light->position;\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightSetDirection(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 4);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetDirection(userData->light,\r\n                      luaL_checknumber(L, 2),\r\n                      luaL_checknumber(L, 3),\r\n                      luaL_checknumber(L, 4));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetDirection(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    Vectormath::Aos::Vector3 *out = dmScript::CheckVector3(L, 2);\r\n    *out = userData->light->direction;\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightSetColor(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 5);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetColor(userData->light,\r\n                  luaL_checknumber(L, 2),\r\n                  luaL_checknumber(L, 3),\r\n                  luaL_checknumber(L, 4),\r\n                  luaL_checknumber(L, 5));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetColor(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    Vectormath::Aos::Vector4 *out = dmScript::CheckVector4(L, 2);\r\n    *out = userData->light->color;\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightSetRadius(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetRadius(userData->light, luaL_checknumber(L, 2));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetRadius(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    lua_pushnumber(L, userData->light->radius);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightSetSmoothness(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetSmoothness(userData->light, luaL_checknumber(L, 2));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetSmoothness(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    lua_pushnumber(L, userData->light->smoothness);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightSetCutoff(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetCutoff(userData->light, luaL_checknumber(L, 2));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetCutoff(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    lua_pushnumber(L, userData->light->cutoff);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightSetSpecular(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    LightSetSpecular(userData->light, luaL_checknumber(L, 2));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightGetSpecular(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    lua_pushnumber(L, userData->light->specular);\r\n\r\n    return 1;\r\n}\r\n\r\n\r\nstatic int LuaLightSetEnabled(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 2);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n    bool enabled = lua_toboolean(L, 2);\r\n\r\n    LightSetEnabled(userData->light, enabled);\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightIsEnabled(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 1);\r\n    LuaLightUserData* userData = LightUserdataCheck(L, 1);\r\n\r\n    lua_pushboolean(L, userData->light->enabled);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic const luaL_Reg functions[] = {\r\n    {\"set_position\", LuaLightSetPosition},\r\n    {\"get_position\", LuaLightGetPosition},\r\n    {\"set_direction\", LuaLightSetDirection},\r\n    {\"get_direction\", LuaLightGetDirection},\r\n    {\"set_color\", LuaLightSetColor},\r\n    {\"get_color\", LuaLightGetColor},\r\n    {\"set_radius\", LuaLightSetRadius},\r\n    {\"get_radius\", LuaLightGetRadius},\r\n    {\"set_smoothness\", LuaLightSetSmoothness},\r\n    {\"get_smoothness\", LuaLightGetSmoothness},\r\n    {\"set_cutoff\", LuaLightSetCutoff},\r\n    {\"get_cutoff\", LuaLightGetCutoff},\r\n    {\"set_specular\", LuaLightSetSpecular},\r\n    {\"get_specular\", LuaLightGetSpecular},\r\n    {\"set_enabled\", LuaLightSetEnabled},\r\n    {\"is_enabled\", LuaLightIsEnabled},\r\n    {\"__gc\", LuaLightUserdataGC},\r\n    {\"__tostring\", LuaLightToString},\r\n    {NULL, NULL}\r\n};\r\n//endregion\r\n\r\nclass LightsManager {\r\npublic:\r\n    bool inited = false;\r\n    Light* lights = NULL;\r\n    LightCluster* clusters = NULL;\r\n    Frustum frustum = Frustum(dmVMath::Matrix4());\r\n    dmVMath::Matrix4 view;\r\n\r\n    dmArray<Light*> lightsPool;\r\n    dmArray<Light*> lightsInWorld;\r\n    dmArray<Light*> lightsVisibleInWorld;\r\n    int numLights,maxLightsPerCluster,pixelsPerCluster;\r\n    uint8_t* encodedClusterLights;//precalculate num light in cluster and store in rgba\r\n    int totalClusters;\r\n    int xSlice, ySlice, zSlice;\r\n    int debugVisibleLights = 0;\r\n\r\n    float cameraAspect, cameraFov, cameraFar;\r\n\r\n    dmBuffer::HBuffer textureBuffer = 0x0;\r\n    int textureWidth, textureHeight;\r\n    int textureParamsRef = LUA_NOREF;\r\n    dmhash_t texturePath = HASH_EMPTY;\r\n\r\n\r\n    LightsManager(){\r\n\r\n    }\r\n    ~LightsManager(){\r\n        delete[] lights;\r\n        delete[] clusters;\r\n        delete[] encodedClusterLights;\r\n        //need L to unref\r\n        //luaL_unref(L, LUA_REGISTRYINDEX, textureParamsRef);\r\n        //for some reasons engine crash when destroy texture buffer. Maybe it destroy in other place when app is closed.\r\n        //dmBuffer::Destroy(textureBuffer);\r\n    }\r\n\r\n    void init(lua_State* L, int numLights, int xSlice, int ySlice, int zSlice, int maxLightsPerCluster){\r\n        assert(!inited);\r\n        assert(numLights>0);\r\n        assert(xSlice>0);\r\n        assert(ySlice>0);\r\n        assert(zSlice>0);\r\n        assert(maxLightsPerCluster>0);\r\n        inited = true;\r\n        this->numLights = numLights;\r\n        this->xSlice = xSlice;\r\n        this->ySlice = ySlice;\r\n        this->zSlice = zSlice;\r\n        this->maxLightsPerCluster = maxLightsPerCluster;\r\n        //1 pixel(rgba) lights count\r\n        //max_lights_per_cluster * 1pixel(rgba) light idx\r\n        pixelsPerCluster = 1 + maxLightsPerCluster;\r\n        lights = new Light[numLights];\r\n        lightsPool.SetCapacity(numLights);\r\n        lightsInWorld.SetCapacity(numLights);\r\n        lightsVisibleInWorld.SetCapacity(numLights);\r\n\r\n        for (int i = 0; i < numLights; ++i) {\r\n            Light* light = &lights[i];\r\n             // Initialize default values for each light\r\n            light->index = numLights-1-i;\r\n            dmVMath::Vector4 encodedIndex = EncodeFloatRGBA(light->index,0,numLights+1)*255;\r\n            light->encodedIndex[0] = encodedIndex.getX();\r\n            light->encodedIndex[1] = encodedIndex.getY();\r\n            light->encodedIndex[2] = encodedIndex.getZ();\r\n            light->encodedIndex[3] = encodedIndex.getW();\r\n            light->enabled = false;\r\n            LightReset(light);\r\n            lightsPool.Push(light);\r\n        }\r\n\r\n        totalClusters = xSlice * ySlice * zSlice;\r\n        clusters = new LightCluster[totalClusters];\r\n\r\n        encodedClusterLights = new uint8_t[maxLightsPerCluster*4];\r\n        uint8_t* encodedClusterLightsIterator = encodedClusterLights;\r\n        for (int i = 0; i < maxLightsPerCluster; ++i) {\r\n            dmVMath::Vector4 lights = EncodeFloatRGBA(i,0,maxLightsPerCluster+1)*255;\r\n            encodedClusterLightsIterator[0] = lights.getX();\r\n            encodedClusterLightsIterator[1] = lights.getY();\r\n            encodedClusterLightsIterator[2] = lights.getZ();\r\n            encodedClusterLightsIterator[3] = lights.getW();\r\n            encodedClusterLightsIterator+=4;\r\n        }\r\n\r\n        int pixels = LIGHT_PIXELS * numLights + totalClusters * pixelsPerCluster;\r\n        FindTextureDimensions(pixels, textureWidth, textureHeight);\r\n        dmLogInfo(\"Total pixels:%d.Lights texture: %d x %d\", pixels,textureWidth, textureHeight);\r\n\r\n        /*\r\n        //not worked when init in render.\r\n        //resource not exited yet\r\n        //create params for texture use it later when changed texture\r\n        lua_getglobal(L, \"resource\");\r\n\r\n        lua_getfield(L, -1, \"TEXTURE_TYPE_2D\");\r\n        int textureType2D = lua_tointeger(L, -1);\r\n        lua_pop(L, 1);\r\n\r\n        lua_getfield(L, -1, \"TEXTURE_FORMAT_RGBA\");\r\n        int textureFormatRGBA = lua_tointeger(L, -1);\r\n        lua_pop(L, 1);\r\n\r\n        lua_pop(L, 1);\r\n        */\r\n        //\r\n      int textureType2D = 0;\r\n      int textureFormatRGBA = 3;\r\n\r\n        // Create params\r\n        lua_newtable(L);\r\n\r\n        // Set width\r\n        lua_pushstring(L, \"width\");\r\n        lua_pushinteger(L, textureWidth);\r\n        lua_settable(L, -3);\r\n\r\n        // Set height\r\n        lua_pushstring(L, \"height\");\r\n        lua_pushinteger(L, textureHeight);\r\n        lua_settable(L, -3);\r\n\r\n        // Set type\r\n        lua_pushstring(L, \"type\");\r\n        lua_pushinteger(L, textureType2D);\r\n        lua_settable(L, -3);\r\n\r\n        // Set format\r\n        lua_pushstring(L, \"format\");\r\n        lua_pushinteger(L, textureFormatRGBA);\r\n        lua_settable(L, -3);\r\n\r\n        // Set num_mip_maps\r\n        lua_pushstring(L, \"num_mip_maps\");\r\n        lua_pushinteger(L, 1);\r\n        lua_settable(L, -3);\r\n\r\n        // Store userdata in the registry and save the reference\r\n        textureParamsRef = luaL_ref(L, LUA_REGISTRYINDEX);\r\n\r\n        dmBuffer::Result r = dmBuffer::Create(textureWidth * textureHeight, rgba_buffer_decl,1, &textureBuffer);\r\n        if (r != dmBuffer::RESULT_OK) {\r\n            dmLogError(\"Failed to create lights texture buffer\");\r\n            return;\r\n        }\r\n\r\n        uint8_t* values = 0x0;\r\n        uint32_t stride = 0;\r\n        dmBuffer::Result dataResult = dmBuffer::GetStream(textureBuffer, HASH_RGBA, (void**)&values, 0x0, 0x0, &stride);\r\n        if (dataResult != dmBuffer::RESULT_OK) {\r\n            luaL_error(L,\"can't get stream for lights texture\");\r\n        }\r\n\r\n        uint8_t* clusterValues = values + numLights * LIGHT_PIXELS * stride;\r\n        for (int i = 0; i < totalClusters; ++i) {\r\n            LightCluster* cluster = &clusters[i];\r\n            cluster->numLights = 0;\r\n            cluster->clusterStart = clusterValues;\r\n            clusterValues += pixelsPerCluster * stride;\r\n        }\r\n    }\r\nprivate:\r\n    LightsManager(const LightsManager&);\r\n};\r\n\r\ninline void LightsManagerUpdateLights(lua_State* L,LightsManager* lightsManager){\r\n    assert(lightsManager->inited);\r\n    if(lightsManager->texturePath==HASH_EMPTY){\r\n        luaL_error(L,\"LightsManager texture path not set\");\r\n    }\r\n\r\n    // Update lights\r\n   lightsManager->lightsVisibleInWorld.SetSize(0);\r\n\r\n    for (int i = 0; i < lightsManager->lightsInWorld.Size(); ++i) {\r\n        Light* light = lightsManager->lightsInWorld[i];\r\n        bool addToScene = LightIsAddLightToScene(light);\r\n        if (addToScene) {\r\n            addToScene = lightsManager->frustum.IsBoxVisible(dmVMath::Vector3(light->aabb[0], light->aabb[1], light->aabb[2]),\r\n                                                            dmVMath::Vector3(light->aabb[3], light->aabb[4], light->aabb[5]));\r\n        }\r\n        if(addToScene){\r\n            lightsManager->lightsVisibleInWorld.Push(light);\r\n        }\r\n    }\r\n\r\n    //update clusters https://github.com/AmanSachan1/WebGL-Clustered-Deferred-Forward-Plus/blob/master/src/renderers/clustered.js\r\n    //mark clusters empty\r\n    for(int i=0;i<lightsManager->totalClusters;++i){\r\n        lightsManager->clusters[i].numLights = 0;\r\n        lightsManager->clusters[i].currentLightStart = lightsManager->clusters[i].clusterStart+4;\r\n    }\r\n    lightsManager->debugVisibleLights = 0;\r\n\r\n    //instead of using the farclip plane as the arbitrary plane to base all our calculations and division splitting off of\r\n    float tan_Vertical_FoV_by_2 = tan(lightsManager->cameraFov * 0.5);\r\n    float zStride = (lightsManager->cameraFar) / lightsManager->zSlice;\r\n\r\n    for (int i = 0; i < lightsManager->lightsVisibleInWorld.Size(); ++i) {\r\n         Light* l = lightsManager->lightsVisibleInWorld[i];\r\n\r\n         dmVMath::Vector4 pos = lightsManager->view * dmVMath::Vector4(l->position.getX(),l->position.getY(),\r\n            l->position.getZ(),1);\r\n         pos.setZ(-pos.getZ());\r\n\r\n        float x1 = pos.getX() - l->radius;\r\n        float y1 = pos.getY() - l->radius;\r\n        float z1 = pos.getZ() - l->radius;\r\n        float x2 = pos.getX() + l->radius;\r\n        float y2 = pos.getY() + l->radius;\r\n        float z2 = pos.getZ() + l->radius;\r\n\r\n      //  dmLogInfo(\"x1:%f x2:%f y1:%f y2:%f z1:%f z2:%f\",x1,x2,y1,y2,z1,z2);\r\n\r\n        float h_lightFrustum = abs(tan_Vertical_FoV_by_2 * pos.getZ() * 2);\r\n        float w_lightFrustum = abs(lightsManager->cameraAspect * h_lightFrustum);\r\n\r\n        //fixed bad values when xStride == 0\r\n        float xStride = fmax(w_lightFrustum / lightsManager->xSlice,0.000001);\r\n        float yStride = fmax(h_lightFrustum / lightsManager->ySlice,0.000001);\r\n\r\n        //Need to extend this by -1 and +1 to avoid edge cases where light\r\n        //technically could fall outside the bounds we make because the planes themeselves are tilted by some angle\r\n        // the effect is exaggerated the steeper the angle the plane makes is\r\n        int zStartIndex = floor(z1 / zStride)-1;\r\n        int zEndIndex = floor(z2 / zStride)+1;\r\n      //  dmLogInfo(\"zStride:%f zStartIndex:%d zEndIndex:%d\",zStride,zStartIndex,zEndIndex);\r\n        int yStartIndex = floor((y1 + h_lightFrustum * 0.5) / yStride);\r\n        int yEndIndex = floor((y2 + h_lightFrustum * 0.5) / yStride);\r\n        int xStartIndex = floor((x1 + w_lightFrustum * 0.5) / xStride) - 1;\r\n        int xEndIndex = floor((x2 + w_lightFrustum * 0.5) / xStride) + 1;\r\n\r\n        if((zStartIndex < 0 && zEndIndex < 0) || (zStartIndex >= lightsManager->zSlice && zEndIndex >= lightsManager->zSlice)){\r\n            continue; //light wont fall into any cluster\r\n        }\r\n        if((yStartIndex < 0 && yEndIndex < 0) || (yStartIndex >= lightsManager->ySlice && yEndIndex >= lightsManager->ySlice)){\r\n            continue; //light wont fall into any cluster\r\n        }\r\n        if((xStartIndex < 0 && xEndIndex < 0) || (xStartIndex >= lightsManager->xSlice && xEndIndex >= lightsManager->xSlice)){\r\n            continue; //light wont fall into any cluster\r\n        }\r\n\r\n        lightsManager->debugVisibleLights++;\r\n\r\n        zStartIndex = fmax(0, fmin(zStartIndex, lightsManager->zSlice - 1));\r\n        zEndIndex = fmax(0, fmin(zEndIndex, lightsManager->zSlice - 1));\r\n\r\n        yStartIndex = fmax(0, fmin(yStartIndex, lightsManager->ySlice - 1));\r\n        yEndIndex = fmax(0, fmin(yEndIndex, lightsManager->ySlice - 1));\r\n\r\n        xStartIndex = fmax(0, fmin(xStartIndex, lightsManager->xSlice - 1));\r\n        xEndIndex = fmax(0, fmin(xEndIndex, lightsManager->xSlice - 1));\r\n\r\n       // zStartIndex = 0;\r\n       // zEndIndex = lightsManager->zSlice-1;\r\n\r\n       // yStartIndex = 0;\r\n       // yEndIndex = lightsManager->ySlice-1;\r\n\r\n       // xStartIndex = 0;\r\n       // xEndIndex = lightsManager->xSlice-1;\r\n\r\n\r\n        for (int z = zStartIndex; z <= zEndIndex; ++z) {\r\n            int zOffset = z * lightsManager->xSlice * lightsManager->ySlice;\r\n            for (int y = yStartIndex; y <= yEndIndex; ++y) {\r\n                int yOffset = y * lightsManager->xSlice;\r\n                int zyOffset = zOffset + yOffset;\r\n                for (int x = xStartIndex; x <= xEndIndex; ++x) {\r\n                    int id = zyOffset + x;\r\n                    LightCluster& cluster = lightsManager->clusters[id];\r\n\r\n                    if (cluster.numLights < lightsManager->maxLightsPerCluster) {\r\n                        memcpy(cluster.currentLightStart, l->encodedIndex, 4);\r\n                        cluster.numLights++;\r\n                        cluster.currentLightStart +=4;\r\n                    } else {\r\n                        dmLogWarning(\"Cluster %d already has the maximum number of lights\", id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    //dmLogInfo(\"Lights all:%d. Visible:%d\",lightsManager->lightsInWorld.Size(), lightsManager->lightsVisibleInWorld.Size());\r\n\r\n    uint8_t* values = 0x0;\r\n    uint32_t stride = 0;\r\n    dmBuffer::Result dataResult = dmBuffer::GetStream(lightsManager->textureBuffer, HASH_RGBA, (void**)&values, 0x0, 0x0, &stride);\r\n    if (dataResult != dmBuffer::RESULT_OK) {\r\n        luaL_error(L,\"can't get stream for lights texture\");\r\n    }\r\n\r\n    for (int i = 0; i < lightsManager->lightsVisibleInWorld.Size(); ++i) {\r\n        Light* light = lightsManager->lightsVisibleInWorld[i];\r\n        if(light->dirty){\r\n            LightWriteToBuffer(light, values+light->index*LIGHT_PIXELS*stride, stride);\r\n            light->dirty = false;\r\n        }\r\n    }\r\n\r\n    for(int i=0;i<lightsManager->totalClusters;++i){\r\n        //write num lights of cluster\r\n        LightCluster& cluster = lightsManager->clusters[i];\r\n        memcpy(cluster.clusterStart, lightsManager->encodedClusterLights+cluster.numLights*4, 4);\r\n    }\r\n\r\n     dmBuffer::UpdateContentVersion(lightsManager->textureBuffer);\r\n\r\n\r\n    // Update clusters\r\n\r\n    //Update texture\r\n    // Step 1: Push the 'resource.set_texture' function onto the stack\r\n    lua_getglobal(L, \"resource\");\r\n    lua_getfield(L, -1, \"set_texture\");\r\n    lua_remove(L, -2); // Remove 'resource' table from the stack\r\n\r\n    // Step 2: Push the arguments\r\n    dmScript::PushHash(L, lightsManager->texturePath);\r\n    lua_rawgeti(L, LUA_REGISTRYINDEX, lightsManager->textureParamsRef);\r\n    dmScript::LuaHBuffer luabuf(lightsManager->textureBuffer, dmScript::OWNER_C);\r\n    PushBuffer(L, luabuf);\r\n\r\n    // Step 3: Call the function\r\n    if (lua_pcall(L, 3, 0, 0)!= 0) {\r\n        // Handle error\r\n        const char* error_msg = lua_tostring(L, -1);\r\n        lua_pop(L, 1); // Pop error message\r\n        luaL_error(L, \"can't set light texture. %s\",error_msg);\r\n    }\r\n}\r\n\r\n\r\nextern LightsManager g_lightsManager;// add g_lightsManager in extension.cpp\r\n\r\n\r\nstatic int LuaLightsManagerInit(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 5);\r\n    if(g_lightsManager.inited){\r\n        dmLogError(\"LightsManager already inited\");\r\n        return 0;\r\n    }\r\n\r\n    int numLights = luaL_checkinteger(L, 1);\r\n    int xSlice = luaL_checkinteger(L, 2);\r\n    int ySlice = luaL_checkinteger(L, 3);\r\n    int zSlice = luaL_checkinteger(L, 4);\r\n    int maxLightsPerCluster = luaL_checkinteger(L, 5);\r\n\r\n    if (numLights < 0) { return DM_LUA_ERROR(\"numLights must be non-negative\");}\r\n    if (xSlice < 0) { return DM_LUA_ERROR(\"xSlice must be non-negative\");}\r\n    if (ySlice < 0) { return DM_LUA_ERROR(\"ySlice must be non-negative\");}\r\n    if (zSlice < 0) { return DM_LUA_ERROR(\"zSlice must be non-negative\");}\r\n    if (maxLightsPerCluster < 0) { return DM_LUA_ERROR(\"maxLightsPerCluster must be non-negative\");}\r\n\r\n    g_lightsManager.init(L, numLights, xSlice, ySlice, zSlice, maxLightsPerCluster);\r\n\r\n    dmLogInfo(\"LightsManager inited.Lights:%d xSlice:%d ySlice:%d zSlice:%d maxLightsPerCluster:%d\" ,\r\n        numLights, xSlice, ySlice, zSlice, maxLightsPerCluster);\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerCreateLight(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n\r\n    if(g_lightsManager.lightsPool.Empty()){\r\n        return DM_LUA_ERROR(\"LightsManager lightsPool is empty\");\r\n    }\r\n\r\n    Light* light = g_lightsManager.lightsPool[g_lightsManager.lightsPool.Size()-1];\r\n    g_lightsManager.lightsPool.Pop();\r\n\r\n    g_lightsManager.lightsInWorld.Push(light);\r\n\r\n\r\n   LuaLightUserData* user_data = (LuaLightUserData*)lua_newuserdata(L, sizeof(LuaLightUserData));\r\n   user_data->light = light;\r\n   user_data->valid = true;\r\n\r\n\r\n    if (luaL_newmetatable(L, LIGHT_META)) {\r\n        luaL_register (L, NULL,functions);\r\n        lua_pushvalue(L, -1);\r\n        lua_setfield(L, -1, \"__index\");\r\n    }\r\n    lua_setmetatable(L, -2);\r\n\r\n\r\n    return 1;\r\n}\r\nstatic int LuaLightsManagerDestroyLight(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n\r\n    LuaLightUserData* userData = (LuaLightUserData*)luaL_checkudata(L, 1, LIGHT_META);\r\n    if (!userData->valid) {return 0;}\r\n\r\n    userData->valid = false;\r\n\r\n    LightReset(userData->light);\r\n    g_lightsManager.lightsPool.Push(userData->light);\r\n\r\n    return 0;\r\n}\r\nstatic int LuaLightsManagerUpdateLights(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 0);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n\r\n    LightsManagerUpdateLights(L,&g_lightsManager);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nstatic int LuaLightsManagerGetTexturePath(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n    dmScript::PushHash(L, g_lightsManager.texturePath);\r\n\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightsManagerSetTexturePath(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n    g_lightsManager.texturePath = dmScript::CheckHash(L,1);\r\n\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerGetTextureSize(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 2);\r\n    check_arg_count(L, 0);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n    lua_pushnumber(L, g_lightsManager.textureWidth);\r\n    lua_pushnumber(L, g_lightsManager.textureHeight);\r\n\r\n    return 2;\r\n}\r\n\r\n\r\nstatic int LuaLightsManagerSetFrustumMatrix(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n    g_lightsManager.frustum.SetMatrix(*dmScript::CheckMatrix4(L,1));\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerSetViewMatrix(lua_State* L){\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    if(!g_lightsManager.inited){\r\n        return DM_LUA_ERROR(\"LightsManager not inited\");\r\n    }\r\n    g_lightsManager.view = *dmScript::CheckMatrix4(L,1);\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerSetCameraAspect(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    g_lightsManager.cameraAspect =  luaL_checknumber(L, 1);\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerSetCameraFov(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    g_lightsManager.cameraFov =  luaL_checknumber(L, 1);\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerSetCameraFar(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 0);\r\n    check_arg_count(L, 1);\r\n    g_lightsManager.cameraFar =  luaL_checknumber(L, 1);\r\n    return 0;\r\n}\r\n\r\nstatic int LuaLightsManagerGetMaxLights(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.numLights);\r\n    return 1;\r\n}\r\nstatic int LuaLightsManagerGetMaxRadius(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,LIGHT_RADIUS_MAX);\r\n    return 1;\r\n}\r\nstatic int LuaLightsManagerGetBordersX(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 2);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,LIGHT_MIN_POSITION_X);\r\n    lua_pushnumber(L,LIGHT_MAX_POSITION_X);\r\n    return 2;\r\n}\r\nstatic int LuaLightsManagerGetBordersY(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 2);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,LIGHT_MIN_POSITION_Y);\r\n    lua_pushnumber(L,LIGHT_MAX_POSITION_Y);\r\n    return 2;\r\n}\r\n\r\nstatic int LuaLightsManagerGetBordersZ(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 2);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,LIGHT_MIN_POSITION_Z);\r\n    lua_pushnumber(L,LIGHT_MAX_POSITION_Z);\r\n    return 2;\r\n}\r\n\r\nstatic int LuaLightsManagerGetXSlice(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.xSlice);\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightsManagerGetYSlice(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.ySlice);\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightsManagerGetZSlice(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.zSlice);\r\n    return 1;\r\n}\r\n\r\nstatic int LuaLightsManagerGetZSliceForShader(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.cameraFar/g_lightsManager.zSlice);\r\n    return 1;\r\n}\r\n\r\n\r\nstatic int LuaLightsManagerGetLightsPerCluster(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.maxLightsPerCluster);\r\n    return 1;\r\n}\r\nstatic int LuaLightsManagerGetInWorldCount(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.lightsInWorld.Size());\r\n    return 1;\r\n}\r\nstatic int LuaLightsManagerGetInWorldVisibleCount(lua_State* L) {\r\n    DM_LUA_STACK_CHECK(L, 1);\r\n    check_arg_count(L, 0);\r\n    lua_pushnumber(L,g_lightsManager.debugVisibleLights);\r\n    return 1;\r\n}\r\n\r\n\r\n}  // namespace IlluminationLights\r\n\r\n\r\n#endif\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumination/native/include/lights.h b/illumination/native/include/lights.h
--- a/illumination/native/include/lights.h	(revision 26b7e21aced58311d8223b7bb2a65ebca18527ed)
+++ b/illumination/native/include/lights.h	(date 1703664314528)
@@ -10,9 +10,11 @@
 #include <cstring>  // For std::strcpy
 
 
+
 #define LIGHT_META "IlluminationLights.Light"
 #define LIGHT_PIXELS 6 // pixels per light
 #define LIGHT_RADIUS_MAX 64.0 // store in r value of pixel. Mb store as rgba value for better precision?
+#define ENCODE_MAX_UINT_IN_FLOAT 4096//number of lights and clusters should be lower
 
 #define LIGHT_MIN_POSITION_X -511
 #define LIGHT_MAX_POSITION_X 512
@@ -149,19 +151,19 @@
 
 //region Light
 inline void LightSetPosition(Light* light, float x, float y, float z) {
-    if (x < LIGHT_MIN_POSITION_X || x > LIGHT_MAX_POSITION_X) {
-      dmLogWarning("Light X position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_X, LIGHT_MAX_POSITION_X);
-      x = fmax(LIGHT_MIN_POSITION_X, fmin(x, LIGHT_MAX_POSITION_X));
+    if (x < LIGHT_MIN_POSITION_X || x > LIGHT_MAX_POSITION_X-1) {
+      dmLogWarning("Light X position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_X, LIGHT_MAX_POSITION_X-1);
+      x = fmax(LIGHT_MIN_POSITION_X, fmin(x, LIGHT_MAX_POSITION_X-1));
     }
 
-    if (y < LIGHT_MIN_POSITION_Y || y > LIGHT_MAX_POSITION_Y) {
-      dmLogWarning("Light Y position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_Y, LIGHT_MAX_POSITION_Y);
-      y = fmax(LIGHT_MIN_POSITION_Y, fmin(y, LIGHT_MAX_POSITION_Y));
+    if (y < LIGHT_MIN_POSITION_Y || y > LIGHT_MAX_POSITION_Y-1) {
+      dmLogWarning("Light Y position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_Y, LIGHT_MAX_POSITION_Y-1);
+      y = fmax(LIGHT_MIN_POSITION_Y, fmin(y, LIGHT_MAX_POSITION_Y-1));
     }
 
     if (z < LIGHT_MIN_POSITION_Z || z > LIGHT_MAX_POSITION_Z) {
-      dmLogWarning("Light Z position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_Z, LIGHT_MAX_POSITION_Z);
-      z = fmax(LIGHT_MIN_POSITION_Z, fmin(z, LIGHT_MAX_POSITION_Z));
+      dmLogWarning("Light Z position out of bounds. Clamping to [%f, %f].", LIGHT_MIN_POSITION_Z, LIGHT_MAX_POSITION_Z-1);
+      z = fmax(LIGHT_MIN_POSITION_Z, fmin(z, LIGHT_MAX_POSITION_Z-1));
     }
 
 
@@ -233,17 +235,17 @@
 }
 
 inline void LightWriteToBuffer(Light* light, uint8_t* values,  uint32_t stride) {
-    dmVMath::Vector4 posX = EncodeFloatRGBA(light->position.getX(),LIGHT_MIN_POSITION_X,LIGHT_MAX_POSITION_X+1)*255;
+    dmVMath::Vector4 posX = EncodeFloatRGBA(light->position.getX(),LIGHT_MIN_POSITION_X,LIGHT_MAX_POSITION_X)*255;
     values[0] = posX.getX();values[1] = posX.getY();values[2] = posX.getZ();values[3] = posX.getW();
     values+=stride;
 
     //dmLogInfo("light:%d x:%f y:%f z:%f",light->index,light->position.getX(),light->position.getY(),light->position.getZ());
 
-    dmVMath::Vector4 posY = EncodeFloatRGBA(light->position.getY(),LIGHT_MIN_POSITION_Y,LIGHT_MAX_POSITION_Y+1)*255;
+    dmVMath::Vector4 posY = EncodeFloatRGBA(light->position.getY(),LIGHT_MIN_POSITION_Y,LIGHT_MAX_POSITION_Y)*255;
     values[0] = posY.getX();values[1] = posY.getY();values[2] = posY.getZ();values[3] = posY.getW();
     values+=stride;
 
-    dmVMath::Vector4 posZ = EncodeFloatRGBA(light->position.getZ(),LIGHT_MIN_POSITION_Z,LIGHT_MAX_POSITION_Z+1)*255;
+    dmVMath::Vector4 posZ = EncodeFloatRGBA(light->position.getZ(),LIGHT_MIN_POSITION_Z,LIGHT_MAX_POSITION_Z)*255;
     values[0] = posZ.getX();values[1] = posZ.getY();values[2] = posZ.getZ();values[3] = posZ.getW();
     values+=stride;
 
@@ -526,10 +528,12 @@
     void init(lua_State* L, int numLights, int xSlice, int ySlice, int zSlice, int maxLightsPerCluster){
         assert(!inited);
         assert(numLights>0);
+        assert(numLights<ENCODE_MAX_UINT_IN_FLOAT);
         assert(xSlice>0);
         assert(ySlice>0);
         assert(zSlice>0);
         assert(maxLightsPerCluster>0);
+        assert(maxLightsPerCluster<ENCODE_MAX_UINT_IN_FLOAT);
         inited = true;
         this->numLights = numLights;
         this->xSlice = xSlice;
@@ -548,7 +552,7 @@
             Light* light = &lights[i];
              // Initialize default values for each light
             light->index = numLights-1-i;
-            dmVMath::Vector4 encodedIndex = EncodeFloatRGBA(light->index,0,numLights+1)*255;
+            dmVMath::Vector4 encodedIndex = EncodeFloatRGBA(light->index,0,ENCODE_MAX_UINT_IN_FLOAT)*255;
             light->encodedIndex[0] = encodedIndex.getX();
             light->encodedIndex[1] = encodedIndex.getY();
             light->encodedIndex[2] = encodedIndex.getZ();
@@ -559,12 +563,13 @@
         }
 
         totalClusters = xSlice * ySlice * zSlice;
+        assert(totalClusters<ENCODE_MAX_UINT_IN_FLOAT);
         clusters = new LightCluster[totalClusters];
 
         encodedClusterLights = new uint8_t[maxLightsPerCluster*4];
         uint8_t* encodedClusterLightsIterator = encodedClusterLights;
         for (int i = 0; i < maxLightsPerCluster; ++i) {
-            dmVMath::Vector4 lights = EncodeFloatRGBA(i,0,maxLightsPerCluster+1)*255;
+            dmVMath::Vector4 lights = EncodeFloatRGBA(i,0,ENCODE_MAX_UINT_IN_FLOAT)*255;
             encodedClusterLightsIterator[0] = lights.getX();
             encodedClusterLightsIterator[1] = lights.getY();
             encodedClusterLightsIterator[2] = lights.getZ();
Index: illumination/assets/materials/model.fp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>uniform lowp sampler2D DIFFUSE_TEXTURE;\r\n\r\n\r\n#include \"/illumination/assets/materials/shadow/shadow_fp.glsl\"\r\n#include \"/illumination/assets/materials/light_uniforms.glsl\"\r\n\r\n\r\nvarying mediump vec2 var_texcoord0;\r\nvarying highp vec3 var_world_position;\r\nvarying mediump vec3 var_world_normal;\r\nvarying highp vec4 var_view_position;\r\nvarying highp vec3 var_camera_position;\r\n\r\nvoid main() {\r\n    vec4 texture_color = texture2D(DIFFUSE_TEXTURE, var_texcoord0);\r\n    vec3 color = texture_color.rgb;\r\n    // Defold Editor\r\n    // if (sun_position.xyz == vec3(0)) {\r\n    //gl_FragColor = vec4(color.rgb * vec3(0.8), 1.0);\r\n    //  return;\r\n    // }\r\n\r\n    //COLOR\r\n    vec3 illuminance_color = vec3(0);\r\n    vec3 specular_color = vec3(0);\r\n\r\n    vec3 surface_normal = var_world_normal;\r\n    vec3 view_direction = normalize(var_camera_position - var_world_position);\r\n\r\n    // Ambient\r\n    vec3 ambient = ambient_color.rgb * ambient_color.w;\r\n    illuminance_color = illuminance_color + ambient;\r\n\r\n    float axis_x = lights_data.w-lights_data.z+1.0;\r\n    float axis_y = lights_data2.y-lights_data2.x+1.0;\r\n    float axis_z = lights_data2.w-lights_data2.z+1.0;\r\n\r\n\r\n    highp float xStride = screen_size.x/clusters_data.x;\r\n    highp float yStride = screen_size.y/clusters_data.y;\r\n    highp float zStride = clusters_data.z;\r\n\r\n\r\n    int clusterX_index = int(floor(gl_FragCoord.x/ xStride));\r\n    int clusterY_index = int(floor(gl_FragCoord.y/ yStride));\r\n    int clusterZ_index = int(floor(-var_view_position.z) / zStride);\r\n\r\n\r\n\r\n    float clusterID = round(float(clusterX_index) +\r\n    float(clusterY_index) * clusters_data.x +\r\n    float(clusterZ_index) * clusters_data.x * clusters_data.y);\r\n\r\n    highp int cluster_tex_idx = int(round(lights_data.x*float(LIGHT_DATA_PIXELS) + clusterID * (1.0+clusters_data.w)));\r\n    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*(clusters_data.w+1.0)));\r\n\r\n    for (int i = 0; i < num_lights; ++i) {\r\n        highp int light_tex_idx = cluster_tex_idx +1 + i;\r\n        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*(lights_data.x+1.0)));\r\n        // lightIdx = i;\r\n       // if (num_lights!= int(lights_data.x)){\r\n         //   gl_FragColor = vec4(1.0,0.0,0.0, 1.0);\r\n       //     return;\r\n      //  }\r\n        //if (lightIdx != i){\r\n        //    break;\r\n       // }\r\n        //if (lightIdx>460){\r\n          //  gl_FragColor = vec4(1,0,0,1);\r\n            //return;\r\n        //}\r\n\r\n        highp int lightIndex = lightIdx * LIGHT_DATA_PIXELS;\r\n        float x = lights_data.z + rgba_to_float(getData(lightIndex))*axis_x;\r\n        float y = lights_data2.x + rgba_to_float(getData(lightIndex+1))*axis_y;\r\n        float z = lights_data2.z + rgba_to_float(getData(lightIndex+2))*axis_z;\r\n        // vec3 spotDirection = getData(lightIndex+3).xyz;\r\n        vec4 lightColorData = getData(lightIndex+4);\r\n        vec4 lightData = getData(lightIndex+5);\r\n\r\n        vec3 lightPosition = vec3(x, y, z);\r\n        float lightRadius = lightData.x*lights_data.y;\r\n        float lightSmoothness = lightData.y;\r\n        float lightSpecular = lightData.z;\r\n        float lightCutoff = lightData.w;\r\n\r\n\r\n        float lightDistance = length(lightPosition - var_world_position);\r\n        if (lightDistance > lightRadius) {\r\n            // Skip this light source because of distance\r\n            continue;\r\n        }\r\n\r\n        vec3 lightColor = lightColorData.rgb* lightColorData.a;\r\n        vec3 lightDirection = normalize(lightPosition - var_world_position);\r\n        vec3 lightIlluminanceColor = point_light2(lightColor.rgb, lightSmoothness, lightPosition, var_world_position, var_world_normal\r\n        , lightSpecular, view_direction);\r\n\r\n\r\n\r\n        if (lightCutoff < 1.0) {\r\n            vec3 spotDirection = getData(lightIndex+3).xyz* 2.0 - vec3(1.0);\r\n            float spot_theta = dot(lightDirection, normalize(spotDirection));\r\n\r\n            float spot_cutoff = lightCutoff * 2.0 - 1.0;\r\n\r\n            if (spot_theta <= spot_cutoff) {\r\n                continue;\r\n            }\r\n\r\n            if (lightSmoothness > 0.0) {\r\n                float spot_cutoff_inner = (spot_cutoff + 1.0) * (1.0 - lightSmoothness) - 1.0;\r\n                float spot_epsilon = spot_cutoff_inner - spot_cutoff;\r\n                float spot_intensity = clamp((spot_cutoff - spot_theta) / spot_epsilon, 0.0, 1.0);\r\n\r\n                lightIlluminanceColor = lightIlluminanceColor * spot_intensity;;\r\n            }\r\n        }\r\n\r\n        illuminance_color = illuminance_color + lightIlluminanceColor;\r\n\r\n        //\r\n    }\r\n\r\n\r\n    //REGION SHADOW -----------------\r\n    // shadow map\r\n    vec4 depth_proj = var_texcoord0_shadow / var_texcoord0_shadow.w;\r\n    float shadow = shadow_calculation(depth_proj.xyzw);\r\n    vec3 shadow_color = shadow_color.xyz*shadow_color.w*(sunlight_color.w) * shadow;\r\n\r\n    vec3 diff_light = vec3(0);\r\n    diff_light += max(direct_light(sunlight_color.rgb, sun_position.xyz, var_world_position.xyz, var_world_normal, shadow_color)*sunlight_color.w, 0.0);\r\n    diff_light += vec3(illuminance_color.xyz);\r\n\r\n    color.rgb = color.rgb * (min(diff_light, 1.0));\r\n\r\n    // Fog\r\n    float dist = abs(var_view_position.z);\r\n    float fog_max = fog.y;\r\n    float fog_min = fog.x;\r\n    float fog_factor = clamp((fog_max - dist) / (fog_max - fog_min) + fog_color.a, 0.0, 1.0);\r\n    color = mix(fog_color.rgb, color, fog_factor);\r\n\r\n\r\n    gl_FragColor = vec4(color, texture_color.a);\r\n\r\n    //float colorz = floor(-var_view_position.z-camNear)/clusters_data.z;\r\n  //  gl_FragColor = vec4(float(clusterX_index)/clusters_data.x,float(clusterY_index)/clusters_data.y,float(clusterZ_index)/1.0, texture_color.a);\r\n   // gl_FragColor = vec4(float(clusterZ_index)/5.0,float(clusterZ_index)/5.0,float(clusterZ_index)/5.0, texture_color.a);\r\n    //gl_FragColor = vec4(clusterZ_index/10.0,color.g,color.b, texture_color.a);\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumination/assets/materials/model.fp b/illumination/assets/materials/model.fp
--- a/illumination/assets/materials/model.fp	(revision 26b7e21aced58311d8223b7bb2a65ebca18527ed)
+++ b/illumination/assets/materials/model.fp	(date 1703664034701)
@@ -5,6 +5,7 @@
 #include "/illumination/assets/materials/light_uniforms.glsl"
 
 
+
 varying mediump vec2 var_texcoord0;
 varying highp vec3 var_world_position;
 varying mediump vec3 var_world_normal;
@@ -52,11 +53,11 @@
     float(clusterZ_index) * clusters_data.x * clusters_data.y);
 
     highp int cluster_tex_idx = int(round(lights_data.x*float(LIGHT_DATA_PIXELS) + clusterID * (1.0+clusters_data.w)));
-    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*(clusters_data.w+1.0)));
+    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*ENCODE_MAX_UINT_IN_FLOAT));
 
     for (int i = 0; i < num_lights; ++i) {
         highp int light_tex_idx = cluster_tex_idx +1 + i;
-        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*(lights_data.x+1.0)));
+        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*ENCODE_MAX_UINT_IN_FLOAT));
         // lightIdx = i;
        // if (num_lights!= int(lights_data.x)){
          //   gl_FragColor = vec4(1.0,0.0,0.0, 1.0);
Index: illumination/assets/materials/light_uniforms.glsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef light_fp\r\n#define light_fp\r\n\r\n#define LIGHT_DATA_PIXELS 6\r\n/*\r\nLIGHT DATA 6 pixels\r\nposition.x -> rgba\r\nposition.y -> rgba\r\nposition.z -> rgba\r\n\r\ndirection.xyz -> rgb (a not used)\r\ncolor.xyzw -> rgba()\r\n\r\nradius, smoothnes, specular, cutoff -> rgba()\r\n\r\n*/\r\n\r\nuniform highp sampler2D DATA_TEXTURE;\r\n\r\nuniform lowp vec4 ambient_color;\r\nuniform lowp vec4 sunlight_color;\r\nuniform lowp vec4 fog_color;\r\nuniform highp vec4 fog;\r\n\r\nuniform highp vec4 light_texture_data;\r\nuniform highp vec4 lights_data; //lights count,radius_max,x_min,xmax\r\nuniform highp vec4 lights_data2; //y_min,y_max,z_min,z_max\r\nuniform highp vec4 clusters_data; //x_slice, y_slice, z_slice, max_lights_per_cluster\r\nuniform highp vec4 screen_size;\r\n\r\nhighp vec4 getData(highp int index) {\r\n    // Convert linear index to 2D pixel coordinates\r\n    int x = index % int(light_texture_data.x);\r\n    int y = index / int(light_texture_data.x);\r\n\r\n    // Convert pixel coordinates to normalized coordinates\r\n    vec2 normalizedCoords = (vec2(x, y) + 0.5) / light_texture_data.xy;\r\n\r\n    // Sample the texture at the normalized coordinates\r\n    return texture2D(DATA_TEXTURE, normalizedCoords);\r\n}\r\n\r\nconst float phong_shininess = 16.0;\r\n// const vec3 specular_color = vec3(1.0);\r\nvec3 point_light2(vec3 light_color, float power, vec3 light_position, vec3 position, vec3 vnormal, float specular, vec3 view_dir)\r\n{\r\n\r\n    vec3 dist = light_position - position;\r\n    vec3 direction = vec3(normalize(dist));\r\n    float d = length(dist);\r\n\r\n    vec3 reflect_dir = reflect(-direction, vnormal);\r\n    float spec_dot = max(dot(reflect_dir, view_dir), 0.0);\r\n\r\n    float irradiance = max(dot(vnormal, direction), 0.05);\r\n    float attenuation = (1.0/(1.0 + d*power + 2.0*d*d*power*power));\r\n    vec3 diffuse = light_color * irradiance * attenuation;\r\n\r\n    // if (irradiance > 0.0) {\r\n    diffuse += irradiance * attenuation * specular * pow(spec_dot, phong_shininess) * light_color; // *specular_color\r\n    // }\r\n    return diffuse;\r\n}\r\n\r\nvec3 getSpecularColor(vec3 map_specular, float light_specular, vec3 light_color, vec3 light_direction, vec3 surface_normal, vec3 view_direction) {\r\n    if (light_specular == 0.0 || map_specular.x == 0.0) {\r\n        return vec3(0.0);\r\n    }\r\n\r\n    float lambertian = max(dot(light_direction, surface_normal), 0.0);\r\n\r\n    if (lambertian <= 0.0) {\r\n        return vec3(0.0);\r\n    }\r\n\r\n    float surface_shininess = 1.0;\r\n\r\n    vec3 reflection_direction = reflect(-light_direction, surface_normal);\r\n    float specular_value = pow(max(dot(view_direction, reflection_direction), 0.0), surface_shininess);\r\n\r\n    return light_color * light_specular * specular_value;\r\n}\r\n\r\n\r\n\r\n#endif
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/illumination/assets/materials/light_uniforms.glsl b/illumination/assets/materials/light_uniforms.glsl
--- a/illumination/assets/materials/light_uniforms.glsl	(revision 26b7e21aced58311d8223b7bb2a65ebca18527ed)
+++ b/illumination/assets/materials/light_uniforms.glsl	(date 1703664314521)
@@ -2,6 +2,7 @@
 #define light_fp
 
 #define LIGHT_DATA_PIXELS 6
+#define ENCODE_MAX_UINT_IN_FLOAT 4096//number of lights and clusters should be lower
 /*
 LIGHT DATA 6 pixels
 position.x -> rgba
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"d3c0949d-87f0-480e-bb31-9484ef16be7c\" name=\"Changes\" comment=\"native clusters\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/example/main.gui\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/example/main.gui\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/illumination/illumination.lua\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/illumination/illumination.lua\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/illumination/native/include/lights.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/illumination/native/include/lights.h\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/illumination/native/src/extension.cpp\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/illumination/native/src/extension.cpp\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/illumination/render/illumination.render_script\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/illumination/render/illumination.render_script\" afterDir=\"false\" />\r\n    </list>\r\n    <list id=\"32e5cb44-c00a-42d9-8100-60d4880106b6\" name=\"New changelist\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"a23fd832b7b2fdbbdbff380bd6ae5e9bb3c67028\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2YAoVEjPFVxWAIJcS4QBmCSHkEn\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/user/defold/defold-illumination/illumination/native/include&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\user\\defold\\defold-illumination\\illumination\\native\\include\" />\r\n      <recent name=\"C:\\Users\\user\\defold\\defold-illumination\" />\r\n      <recent name=\"C:\\Users\\user\\defold\\defold-illumination\\illumination\\assets\\materials\" />\r\n      <recent name=\"C:\\Users\\user\\defold\\defold-illumination\\illumination\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\r\n      <option name=\"filePath\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"illumination.lua\" type=\"lua.app\" factoryName=\"Lua Application\" temporary=\"true\">\r\n      <option name=\"program\" value=\"lua.exe\" />\r\n      <option name=\"file\" value=\"illumination/illumination.lua\" />\r\n      <option name=\"workingDir\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"debuggerType\" value=\"2\" />\r\n      <option name=\"params\" value=\"\" />\r\n      <option name=\"charset\" value=\"UTF-8\" />\r\n      <option name=\"showConsole\" value=\"true\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Lua Application.illumination.lua\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"add axis capacity\" />\r\n    <MESSAGE value=\"add light data to texture\" />\r\n    <MESSAGE value=\"light data\" />\r\n    <MESSAGE value=\"fixed html\" />\r\n    <MESSAGE value=\"reduce texture size\" />\r\n    <MESSAGE value=\"increase mesh max_count\" />\r\n    <MESSAGE value=\"try count shadowmap projection\" />\r\n    <MESSAGE value=\"clusters at texture\" />\r\n    <MESSAGE value=\"add clusters\" />\r\n    <MESSAGE value=\"clusters worked\" />\r\n    <MESSAGE value=\"shader\" />\r\n    <MESSAGE value=\"fixed web build\" />\r\n    <MESSAGE value=\"fixed web build(precession issues)\" />\r\n    <MESSAGE value=\"check time for update clusters\" />\r\n    <MESSAGE value=\"more culling\" />\r\n    <MESSAGE value=\"light methods\" />\r\n    <MESSAGE value=\"lights methods\" />\r\n    <MESSAGE value=\"init lights texture\" />\r\n    <MESSAGE value=\"native light manager\" />\r\n    <MESSAGE value=\"write lights in texture\" />\r\n    <MESSAGE value=\"add ligths in clusters\" />\r\n    <MESSAGE value=\"native clusters\" />\r\n    <MESSAGE value=\"remove texture\" />\r\n    <MESSAGE value=\"remove old logic\" />\r\n    <MESSAGE value=\"fixed\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"fixed\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 26b7e21aced58311d8223b7bb2a65ebca18527ed)
+++ b/.idea/workspace.xml	(date 1703664034770)
@@ -4,13 +4,11 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="d3c0949d-87f0-480e-bb31-9484ef16be7c" name="Changes" comment="native clusters">
+    <list default="true" id="d3c0949d-87f0-480e-bb31-9484ef16be7c" name="Changes" comment="try use texture handler">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/example/main.gui" beforeDir="false" afterPath="$PROJECT_DIR$/example/main.gui" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/illumination/illumination.lua" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/illumination.lua" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/illumination/assets/materials/light_uniforms.glsl" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/assets/materials/light_uniforms.glsl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/illumination/assets/materials/model.fp" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/assets/materials/model.fp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/illumination/native/include/lights.h" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/native/include/lights.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/illumination/native/src/extension.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/native/src/extension.cpp" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/illumination/render/illumination.render_script" beforeDir="false" afterPath="$PROJECT_DIR$/illumination/render/illumination.render_script" afterDir="false" />
     </list>
     <list id="32e5cb44-c00a-42d9-8100-60d4880106b6" name="New changelist" comment="" />
     <option name="SHOW_DIALOG" value="false" />
@@ -21,7 +19,7 @@
   <component name="Git.Settings">
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="a23fd832b7b2fdbbdbff380bd6ae5e9bb3c67028" />
+        <entry key="$PROJECT_DIR$" value="536bc2e77d0b664a5b77ff70908ba69f6634ec74" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -29,80 +27,19 @@
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
   </component>
-  <component name="ProjectId" id="2YAoVEjPFVxWAIJcS4QBmCSHkEn" />
+  <component name="ProjectId" id="2a4h18OHilx5Qn1UVL6SbDFpSq8" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
-    &quot;last_opened_file_path&quot;: &quot;C:/Users/user/defold/defold-illumination/illumination/native/include&quot;,
-    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,
-    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
-    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;
-  }
-}</component>
-  <component name="RecentsManager">
-    <key name="CopyFile.RECENT_KEYS">
-      <recent name="C:\Users\user\defold\defold-illumination\illumination\native\include" />
-      <recent name="C:\Users\user\defold\defold-illumination" />
-      <recent name="C:\Users\user\defold\defold-illumination\illumination\assets\materials" />
-      <recent name="C:\Users\user\defold\defold-illumination\illumination" />
-    </key>
-  </component>
-  <component name="RunManager">
-    <configuration default="true" type="JetRunConfigurationType">
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="KotlinStandaloneScriptRunConfigurationType">
-      <option name="filePath" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="PythonConfigurationType" factoryName="Python">
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <envs>
-        <env name="PYTHONUNBUFFERED" value="1" />
-      </envs>
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <module name="" />
-      <option name="SCRIPT_NAME" value="" />
-      <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="false" />
-      <option name="EMULATE_TERMINAL" value="false" />
-      <option name="MODULE_MODE" value="false" />
-      <option name="REDIRECT_INPUT" value="false" />
-      <option name="INPUT_FILE" value="" />
-      <method v="2" />
-    </configuration>
-    <configuration name="illumination.lua" type="lua.app" factoryName="Lua Application" temporary="true">
-      <option name="program" value="lua.exe" />
-      <option name="file" value="illumination/illumination.lua" />
-      <option name="workingDir" value="$PROJECT_DIR$" />
-      <option name="debuggerType" value="2" />
-      <option name="params" value="" />
-      <option name="charset" value="UTF-8" />
-      <option name="showConsole" value="true" />
-      <method v="2" />
-    </configuration>
-    <recent_temporary>
-      <list>
-        <item itemvalue="Lua Application.illumination.lua" />
-      </list>
-    </recent_temporary>
-  </component>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "last_opened_file_path": "C:/Users/user/defold/defold-illumination/illumination/native/include/lights.h",
+    "two.files.diff.last.used.file": "C:/Users/user/defold/defold-illumination/illumination/native/include/lights.h"
+  }
+}]]></component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="Vcs.Log.Tabs.Properties">
     <option name="TAB_STATES">
@@ -116,31 +53,17 @@
     </option>
   </component>
   <component name="VcsManagerConfiguration">
-    <MESSAGE value="add axis capacity" />
-    <MESSAGE value="add light data to texture" />
-    <MESSAGE value="light data" />
-    <MESSAGE value="fixed html" />
-    <MESSAGE value="reduce texture size" />
-    <MESSAGE value="increase mesh max_count" />
-    <MESSAGE value="try count shadowmap projection" />
-    <MESSAGE value="clusters at texture" />
-    <MESSAGE value="add clusters" />
-    <MESSAGE value="clusters worked" />
-    <MESSAGE value="shader" />
-    <MESSAGE value="fixed web build" />
-    <MESSAGE value="fixed web build(precession issues)" />
-    <MESSAGE value="check time for update clusters" />
-    <MESSAGE value="more culling" />
-    <MESSAGE value="light methods" />
-    <MESSAGE value="lights methods" />
-    <MESSAGE value="init lights texture" />
-    <MESSAGE value="native light manager" />
-    <MESSAGE value="write lights in texture" />
-    <MESSAGE value="add ligths in clusters" />
-    <MESSAGE value="native clusters" />
-    <MESSAGE value="remove texture" />
-    <MESSAGE value="remove old logic" />
-    <MESSAGE value="fixed" />
-    <option name="LAST_COMMIT_MESSAGE" value="fixed" />
+    <MESSAGE value="use -1,1 shadow map for initial calculation" />
+    <MESSAGE value="another frustum for shadows" />
+    <MESSAGE value="fixed shadow map size" />
+    <MESSAGE value="try fixed shimmering effect" />
+    <MESSAGE value="try fixed shadow shimmering" />
+    <MESSAGE value="do not recreate shadow. Use bigger shadow projection" />
+    <MESSAGE value="fixed gc" />
+    <MESSAGE value="fixed rgba encode/decode" />
+    <MESSAGE value="try use texture handler" />
+    <MESSAGE value="fixed gitignore" />
+    <MESSAGE value="optimize model.fp" />
+    <option name="LAST_COMMIT_MESSAGE" value="optimize model.fp" />
   </component>
 </project>
\ No newline at end of file
