
ÜH×H#version 140
#ifndef GL_ES
#define lowp
#define mediump
#define highp
#endif


out vec4 _DMENGINE_GENERATED_gl_FragColor_0;
uniform lowp sampler2D DIFFUSE_TEXTURE;


#ifndef shadow_fp
#define shadow_fp

#ifndef float_rgba_utils
#define float_rgba_utils

vec4 float_to_rgba(float v){
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc      = fract(enc);
    enc     -= enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
    return enc;
}

highp float rgba_to_float(highp vec4 rgba){
    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));
}

#endif

uniform lowp vec4 shadow_params; 
uniform lowp vec4 shadow_color;
uniform highp vec4 sun_position; 
uniform highp sampler2D SHADOW_TEXTURE;

in highp vec4 var_texcoord0_shadow;

vec2 rand(vec2 co){
    return vec2(fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453),
    fract(sin(dot(co.yx, vec2(12.9898, 78.233))) * 43758.5453)) * 0.00047;
}

float shadow_calculation_mobile(highp vec4 depth_data){
    highp vec2 uv = depth_data.xy;
    
    highp vec4 rgba = texture(SHADOW_TEXTURE, uv);
    float depth = rgba_to_float(rgba);
    
    
    
    float shadow = 1.0 - step(depth_data.z-shadow_params.y,depth);

    if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) shadow = 0.0;

    return shadow;
}

float shadow_calculation(highp vec4 depth_data){
    float shadow = 0.0;
    float texel_size = 1.0 / shadow_params.x;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            highp vec2 uv = depth_data.st + vec2(x,y) * texel_size;
            
            vec4 rgba = texture(SHADOW_TEXTURE, uv);
            float depth = rgba_to_float(rgba);
            
            shadow += depth_data.z - shadow_params.y > depth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    highp vec2 uv = depth_data.xy;
    if (uv.x<0.0) shadow = 0.0;
    if (uv.x>1.0) shadow = 0.0;
    if (uv.y<0.0) shadow = 0.0;
    if (uv.y>1.0) shadow = 0.0;

    return shadow;
}


vec3 direct_light(vec3 light_color, vec3 light_position, vec3 position, vec3 vnormal, vec3 shadow_color){
    vec3 dist = vec3(-5,10,0);
    vec3 direction = normalize(dist);
    float n = max(dot(vnormal, direction), 0.0);
    vec3 diffuse = (light_color - shadow_color) * n;
    return diffuse;
}

#endif
#ifndef light_fp
#define light_fp

#define LIGHT_DATA_PIXELS 6













uniform highp sampler2D DATA_TEXTURE;

uniform lowp vec4 ambient_color;
uniform lowp vec4 sunlight_color;
uniform lowp vec4 fog_color;
uniform highp vec4 fog;

uniform highp vec4 light_texture_data;
uniform highp vec4 lights_data; 
uniform highp vec4 lights_data2; 
uniform highp vec4 clusters_data; 
uniform highp vec4 screen_size;

highp vec4 getData(highp int index) {
    
    int x = index % int(light_texture_data.x);
    int y = index / int(light_texture_data.x);

    
    vec2 normalizedCoords = (vec2(x, y) + 0.5) / light_texture_data.xy;

    
    return texture(DATA_TEXTURE, normalizedCoords);
}

const float phong_shininess = 16.0;

vec3 point_light2(vec3 light_color, float power, vec3 light_position, vec3 position, vec3 vnormal, float specular, vec3 view_dir)
{

    vec3 dist = light_position - position;
    vec3 direction = vec3(normalize(dist));
    float d = length(dist);

    vec3 reflect_dir = reflect(-direction, vnormal);
    float spec_dot = max(dot(reflect_dir, view_dir), 0.0);

    float irradiance = max(dot(vnormal, direction), 0.05);
    float attenuation = (1.0/(1.0 + d*power + 2.0*d*d*power*power));
    vec3 diffuse = light_color * irradiance * attenuation;

    
    diffuse += irradiance * attenuation * specular * pow(spec_dot, phong_shininess) * light_color; 
    
    return diffuse;
}

vec3 getSpecularColor(vec3 map_specular, float light_specular, vec3 light_color, vec3 light_direction, vec3 surface_normal, vec3 view_direction) {
    if (light_specular == 0.0 || map_specular.x == 0.0) {
        return vec3(0.0);
    }

    float lambertian = max(dot(light_direction, surface_normal), 0.0);

    if (lambertian <= 0.0) {
        return vec3(0.0);
    }

    float surface_shininess = 1.0;

    vec3 reflection_direction = reflect(-light_direction, surface_normal);
    float specular_value = pow(max(dot(view_direction, reflection_direction), 0.0), surface_shininess);

    return light_color * light_specular * specular_value;
}



#endif


in mediump vec2 var_texcoord0;
in highp vec3 var_world_position;
in mediump vec3 var_world_normal;
in highp vec4 var_view_position;
in highp vec3 var_camera_position;

void main() {
    vec4 texture_color = texture(DIFFUSE_TEXTURE, var_texcoord0);
    vec3 color = texture_color.rgb;
    
    
    
    
    

    
    vec3 illuminance_color = vec3(0);
    vec3 specular_color = vec3(0);

    vec3 surface_normal = var_world_normal;
    vec3 view_direction = normalize(var_camera_position - var_world_position);

    
    vec3 ambient = ambient_color.rgb * ambient_color.w;
    illuminance_color = illuminance_color + ambient;

    float axis_x = lights_data.w-lights_data.z;
    float axis_y = lights_data2.y-lights_data2.x;
    float axis_z = lights_data2.w-lights_data2.z;


    highp float xStride = screen_size.x/clusters_data.x;
    highp float yStride = screen_size.y/clusters_data.y;
    highp float zStride = clusters_data.z;


    int clusterX_index = int(floor(gl_FragCoord.x/ xStride));
    int clusterY_index = int(floor(gl_FragCoord.y/ yStride));
    int clusterZ_index = int(floor(-var_view_position.z) / zStride);



    float clusterID = round(float(clusterX_index) +
    float(clusterY_index) * clusters_data.x +
    float(clusterZ_index) * clusters_data.x * clusters_data.y);

    highp int cluster_tex_idx = int(round(lights_data.x*float(LIGHT_DATA_PIXELS) + clusterID * (1.0+clusters_data.w)));
    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*clusters_data.w));

    for (int i = 0; i < num_lights; ++i) {
        highp int light_tex_idx = cluster_tex_idx +1 + i;
        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*lights_data.x));
        
       
         
       
      
        
        
       
        
          
            
        

        highp int lightIndex = lightIdx * LIGHT_DATA_PIXELS;
        float x = lights_data.z + rgba_to_float(getData(lightIndex))*axis_x;
        float y = lights_data2.x + rgba_to_float(getData(lightIndex+1))*axis_y;
        float z = lights_data2.z + rgba_to_float(getData(lightIndex+2))*axis_z;
        
        vec4 lightColorData = getData(lightIndex+4);
        vec4 lightData = getData(lightIndex+5);

        vec3 lightPosition = vec3(x, y, z);
        float lightRadius = lightData.x*lights_data.y;
        float lightSmoothness = lightData.y;
        float lightSpecular = lightData.z;
        float lightCutoff = lightData.w;


        float lightDistance = length(lightPosition - var_world_position);
        if (lightDistance > lightRadius) {
            
            continue;
        }

        vec3 lightColor = lightColorData.rgb* lightColorData.a;
        vec3 lightDirection = normalize(lightPosition - var_world_position);
        vec3 lightIlluminanceColor = point_light2(lightColor.rgb, lightSmoothness, lightPosition, var_world_position, var_world_normal
        , lightSpecular, view_direction);



        if (lightCutoff < 1.0) {
            vec3 spotDirection = getData(lightIndex+3).xyz* 2.0 - vec3(1.0);
            float spot_theta = dot(lightDirection, normalize(spotDirection));

            float spot_cutoff = lightCutoff * 2.0 - 1.0;

            if (spot_theta <= spot_cutoff) {
                continue;
            }

            if (lightSmoothness > 0.0) {
                float spot_cutoff_inner = (spot_cutoff + 1.0) * (1.0 - lightSmoothness) - 1.0;
                float spot_epsilon = spot_cutoff_inner - spot_cutoff;
                float spot_intensity = clamp((spot_cutoff - spot_theta) / spot_epsilon, 0.0, 1.0);

                lightIlluminanceColor = lightIlluminanceColor * spot_intensity;;
            }
        }

        illuminance_color = illuminance_color + lightIlluminanceColor;

        
    }


    
    
    vec4 depth_proj = var_texcoord0_shadow / var_texcoord0_shadow.w;
    float shadow = shadow_calculation(depth_proj.xyzw);
    vec3 shadow_color = shadow_color.xyz*shadow_color.w*(sunlight_color.w) * shadow;

    vec3 diff_light = vec3(0);
    diff_light += max(direct_light(sunlight_color.rgb, sun_position.xyz, var_world_position.xyz, var_world_normal, shadow_color)*sunlight_color.w, 0.0);
    diff_light += vec3(illuminance_color.xyz);

    color.rgb = color.rgb * (min(diff_light, 1.0));

    
    float dist = abs(var_view_position.z);
    float fog_max = fog.y;
    float fog_min = fog.x;
    float fog_factor = clamp((fog_max - dist) / (fog_max - fog_min) + fog_color.a, 0.0, 1.0);
    color = mix(fog_color.rgb, color, fog_factor);


    _DMENGINE_GENERATED_gl_FragColor_0 = vec4(color, texture_color.a);

    
  
   
    
}

±H¬H#version 300 es
precision mediump float;

out vec4 _DMENGINE_GENERATED_gl_FragColor_0;
uniform lowp sampler2D DIFFUSE_TEXTURE;


#ifndef shadow_fp
#define shadow_fp

#ifndef float_rgba_utils
#define float_rgba_utils

vec4 float_to_rgba(float v){
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc      = fract(enc);
    enc     -= enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
    return enc;
}

highp float rgba_to_float(highp vec4 rgba){
    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));
}

#endif

uniform lowp vec4 shadow_params; 
uniform lowp vec4 shadow_color;
uniform highp vec4 sun_position; 
uniform highp sampler2D SHADOW_TEXTURE;

in highp vec4 var_texcoord0_shadow;

vec2 rand(vec2 co){
    return vec2(fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453),
    fract(sin(dot(co.yx, vec2(12.9898, 78.233))) * 43758.5453)) * 0.00047;
}

float shadow_calculation_mobile(highp vec4 depth_data){
    highp vec2 uv = depth_data.xy;
    
    highp vec4 rgba = texture(SHADOW_TEXTURE, uv);
    float depth = rgba_to_float(rgba);
    
    
    
    float shadow = 1.0 - step(depth_data.z-shadow_params.y,depth);

    if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) shadow = 0.0;

    return shadow;
}

float shadow_calculation(highp vec4 depth_data){
    float shadow = 0.0;
    float texel_size = 1.0 / shadow_params.x;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            highp vec2 uv = depth_data.st + vec2(x,y) * texel_size;
            
            vec4 rgba = texture(SHADOW_TEXTURE, uv);
            float depth = rgba_to_float(rgba);
            
            shadow += depth_data.z - shadow_params.y > depth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    highp vec2 uv = depth_data.xy;
    if (uv.x<0.0) shadow = 0.0;
    if (uv.x>1.0) shadow = 0.0;
    if (uv.y<0.0) shadow = 0.0;
    if (uv.y>1.0) shadow = 0.0;

    return shadow;
}


vec3 direct_light(vec3 light_color, vec3 light_position, vec3 position, vec3 vnormal, vec3 shadow_color){
    vec3 dist = vec3(-5,10,0);
    vec3 direction = normalize(dist);
    float n = max(dot(vnormal, direction), 0.0);
    vec3 diffuse = (light_color - shadow_color) * n;
    return diffuse;
}

#endif
#ifndef light_fp
#define light_fp

#define LIGHT_DATA_PIXELS 6













uniform highp sampler2D DATA_TEXTURE;

uniform lowp vec4 ambient_color;
uniform lowp vec4 sunlight_color;
uniform lowp vec4 fog_color;
uniform highp vec4 fog;

uniform highp vec4 light_texture_data;
uniform highp vec4 lights_data; 
uniform highp vec4 lights_data2; 
uniform highp vec4 clusters_data; 
uniform highp vec4 screen_size;

highp vec4 getData(highp int index) {
    
    int x = index % int(light_texture_data.x);
    int y = index / int(light_texture_data.x);

    
    vec2 normalizedCoords = (vec2(x, y) + 0.5) / light_texture_data.xy;

    
    return texture(DATA_TEXTURE, normalizedCoords);
}

const float phong_shininess = 16.0;

vec3 point_light2(vec3 light_color, float power, vec3 light_position, vec3 position, vec3 vnormal, float specular, vec3 view_dir)
{

    vec3 dist = light_position - position;
    vec3 direction = vec3(normalize(dist));
    float d = length(dist);

    vec3 reflect_dir = reflect(-direction, vnormal);
    float spec_dot = max(dot(reflect_dir, view_dir), 0.0);

    float irradiance = max(dot(vnormal, direction), 0.05);
    float attenuation = (1.0/(1.0 + d*power + 2.0*d*d*power*power));
    vec3 diffuse = light_color * irradiance * attenuation;

    
    diffuse += irradiance * attenuation * specular * pow(spec_dot, phong_shininess) * light_color; 
    
    return diffuse;
}

vec3 getSpecularColor(vec3 map_specular, float light_specular, vec3 light_color, vec3 light_direction, vec3 surface_normal, vec3 view_direction) {
    if (light_specular == 0.0 || map_specular.x == 0.0) {
        return vec3(0.0);
    }

    float lambertian = max(dot(light_direction, surface_normal), 0.0);

    if (lambertian <= 0.0) {
        return vec3(0.0);
    }

    float surface_shininess = 1.0;

    vec3 reflection_direction = reflect(-light_direction, surface_normal);
    float specular_value = pow(max(dot(view_direction, reflection_direction), 0.0), surface_shininess);

    return light_color * light_specular * specular_value;
}



#endif


in mediump vec2 var_texcoord0;
in highp vec3 var_world_position;
in mediump vec3 var_world_normal;
in highp vec4 var_view_position;
in highp vec3 var_camera_position;

void main() {
    vec4 texture_color = texture(DIFFUSE_TEXTURE, var_texcoord0);
    vec3 color = texture_color.rgb;
    
    
    
    
    

    
    vec3 illuminance_color = vec3(0);
    vec3 specular_color = vec3(0);

    vec3 surface_normal = var_world_normal;
    vec3 view_direction = normalize(var_camera_position - var_world_position);

    
    vec3 ambient = ambient_color.rgb * ambient_color.w;
    illuminance_color = illuminance_color + ambient;

    float axis_x = lights_data.w-lights_data.z;
    float axis_y = lights_data2.y-lights_data2.x;
    float axis_z = lights_data2.w-lights_data2.z;


    highp float xStride = screen_size.x/clusters_data.x;
    highp float yStride = screen_size.y/clusters_data.y;
    highp float zStride = clusters_data.z;


    int clusterX_index = int(floor(gl_FragCoord.x/ xStride));
    int clusterY_index = int(floor(gl_FragCoord.y/ yStride));
    int clusterZ_index = int(floor(-var_view_position.z) / zStride);



    float clusterID = round(float(clusterX_index) +
    float(clusterY_index) * clusters_data.x +
    float(clusterZ_index) * clusters_data.x * clusters_data.y);

    highp int cluster_tex_idx = int(round(lights_data.x*float(LIGHT_DATA_PIXELS) + clusterID * (1.0+clusters_data.w)));
    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*clusters_data.w));

    for (int i = 0; i < num_lights; ++i) {
        highp int light_tex_idx = cluster_tex_idx +1 + i;
        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*lights_data.x));
        
       
         
       
      
        
        
       
        
          
            
        

        highp int lightIndex = lightIdx * LIGHT_DATA_PIXELS;
        float x = lights_data.z + rgba_to_float(getData(lightIndex))*axis_x;
        float y = lights_data2.x + rgba_to_float(getData(lightIndex+1))*axis_y;
        float z = lights_data2.z + rgba_to_float(getData(lightIndex+2))*axis_z;
        
        vec4 lightColorData = getData(lightIndex+4);
        vec4 lightData = getData(lightIndex+5);

        vec3 lightPosition = vec3(x, y, z);
        float lightRadius = lightData.x*lights_data.y;
        float lightSmoothness = lightData.y;
        float lightSpecular = lightData.z;
        float lightCutoff = lightData.w;


        float lightDistance = length(lightPosition - var_world_position);
        if (lightDistance > lightRadius) {
            
            continue;
        }

        vec3 lightColor = lightColorData.rgb* lightColorData.a;
        vec3 lightDirection = normalize(lightPosition - var_world_position);
        vec3 lightIlluminanceColor = point_light2(lightColor.rgb, lightSmoothness, lightPosition, var_world_position, var_world_normal
        , lightSpecular, view_direction);



        if (lightCutoff < 1.0) {
            vec3 spotDirection = getData(lightIndex+3).xyz* 2.0 - vec3(1.0);
            float spot_theta = dot(lightDirection, normalize(spotDirection));

            float spot_cutoff = lightCutoff * 2.0 - 1.0;

            if (spot_theta <= spot_cutoff) {
                continue;
            }

            if (lightSmoothness > 0.0) {
                float spot_cutoff_inner = (spot_cutoff + 1.0) * (1.0 - lightSmoothness) - 1.0;
                float spot_epsilon = spot_cutoff_inner - spot_cutoff;
                float spot_intensity = clamp((spot_cutoff - spot_theta) / spot_epsilon, 0.0, 1.0);

                lightIlluminanceColor = lightIlluminanceColor * spot_intensity;;
            }
        }

        illuminance_color = illuminance_color + lightIlluminanceColor;

        
    }


    
    
    vec4 depth_proj = var_texcoord0_shadow / var_texcoord0_shadow.w;
    float shadow = shadow_calculation(depth_proj.xyzw);
    vec3 shadow_color = shadow_color.xyz*shadow_color.w*(sunlight_color.w) * shadow;

    vec3 diff_light = vec3(0);
    diff_light += max(direct_light(sunlight_color.rgb, sun_position.xyz, var_world_position.xyz, var_world_normal, shadow_color)*sunlight_color.w, 0.0);
    diff_light += vec3(illuminance_color.xyz);

    color.rgb = color.rgb * (min(diff_light, 1.0));

    
    float dist = abs(var_view_position.z);
    float fog_max = fog.y;
    float fog_min = fog.x;
    float fog_factor = clamp((fog_max - dist) / (fog_max - fog_min) + fog_color.a, 0.0, 1.0);
    color = mix(fog_color.rgb, color, fog_factor);


    _DMENGINE_GENERATED_gl_FragColor_0 = vec4(color, texture_color.a);

    
  
   
    
}

ÅSÀSprecision mediump float;
uniform lowp sampler2D DIFFUSE_TEXTURE;


#ifndef shadow_fp
#define shadow_fp

#ifndef float_rgba_utils
#define float_rgba_utils

vec4 float_to_rgba(float v){
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
    enc      = fract(enc);
    enc     -= enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
    return enc;
}

highp float rgba_to_float(highp vec4 rgba){
    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));
}

#endif

uniform lowp vec4 shadow_params; //x is texture size y depth_bias
uniform lowp vec4 shadow_color;
uniform highp vec4 sun_position; //sun light position
uniform highp sampler2D SHADOW_TEXTURE;

varying highp vec4 var_texcoord0_shadow;

vec2 rand(vec2 co){
    return vec2(fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453),
    fract(sin(dot(co.yx, vec2(12.9898, 78.233))) * 43758.5453)) * 0.00047;
}

float shadow_calculation_mobile(highp vec4 depth_data){
    highp vec2 uv = depth_data.xy;
    // vec4 rgba = texture2D(SHADOW_TEXTURE, uv + rand(uv));
    highp vec4 rgba = texture2D(SHADOW_TEXTURE, uv);
    float depth = rgba_to_float(rgba);
    //float depth = rgba.x;
    //float shadow = depth_data.z - shadow_params. > depth ? 1.0 : 0.0;
    //float shadow = step(depth,depth_data.z-shadow_params.);
    float shadow = 1.0 - step(depth_data.z-shadow_params.y,depth);

    if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) shadow = 0.0;

    return shadow;
}

float shadow_calculation(highp vec4 depth_data){
    float shadow = 0.0;
    float texel_size = 1.0 / shadow_params.x;//textureSize(tex1, 0);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            highp vec2 uv = depth_data.st + vec2(x,y) * texel_size;
            //vec4 rgba = texture2D(SHADOW_TEXTURE, uv + rand(uv));
            vec4 rgba = texture2D(SHADOW_TEXTURE, uv);
            float depth = rgba_to_float(rgba);
            
            shadow += depth_data.z - shadow_params.y > depth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    highp vec2 uv = depth_data.xy;
    if (uv.x<0.0) shadow = 0.0;
    if (uv.x>1.0) shadow = 0.0;
    if (uv.y<0.0) shadow = 0.0;
    if (uv.y>1.0) shadow = 0.0;

    return shadow;
}

// SUN! DIRECT LIGHT
vec3 direct_light(vec3 light_color, vec3 light_position, vec3 position, vec3 vnormal, vec3 shadow_color){
    vec3 dist = vec3(-5,10,0);
    vec3 direction = normalize(dist);
    float n = max(dot(vnormal, direction), 0.0);
    vec3 diffuse = (light_color - shadow_color) * n;
    return diffuse;
}

#endif
#ifndef light_fp
#define light_fp

#define LIGHT_DATA_PIXELS 6
/*
LIGHT DATA 6 pixels
position.x -> rgba
position.y -> rgba
position.z -> rgba

direction.xyz -> rgb (a not used)
color.xyzw -> rgba()

radius, smoothnes, specular, cutoff -> rgba()

*/

uniform highp sampler2D DATA_TEXTURE;

uniform lowp vec4 ambient_color;
uniform lowp vec4 sunlight_color;
uniform lowp vec4 fog_color;
uniform highp vec4 fog;

uniform highp vec4 light_texture_data;
uniform highp vec4 lights_data; //lights count,radius_max,x_min,xmax
uniform highp vec4 lights_data2; //y_min,y_max,z_min,z_max
uniform highp vec4 clusters_data; //x_slice, y_slice, z_slice, max_lights_per_cluster
uniform highp vec4 screen_size;

highp vec4 getData(highp int index) {
    // Convert linear index to 2D pixel coordinates
    int x = index % int(light_texture_data.x);
    int y = index / int(light_texture_data.x);

    // Convert pixel coordinates to normalized coordinates
    vec2 normalizedCoords = (vec2(x, y) + 0.5) / light_texture_data.xy;

    // Sample the texture at the normalized coordinates
    return texture2D(DATA_TEXTURE, normalizedCoords);
}

const float phong_shininess = 16.0;
// const vec3 specular_color = vec3(1.0);
vec3 point_light2(vec3 light_color, float power, vec3 light_position, vec3 position, vec3 vnormal, float specular, vec3 view_dir)
{

    vec3 dist = light_position - position;
    vec3 direction = vec3(normalize(dist));
    float d = length(dist);

    vec3 reflect_dir = reflect(-direction, vnormal);
    float spec_dot = max(dot(reflect_dir, view_dir), 0.0);

    float irradiance = max(dot(vnormal, direction), 0.05);
    float attenuation = (1.0/(1.0 + d*power + 2.0*d*d*power*power));
    vec3 diffuse = light_color * irradiance * attenuation;

    // if (irradiance > 0.0) {
    diffuse += irradiance * attenuation * specular * pow(spec_dot, phong_shininess) * light_color; // *specular_color
    // }
    return diffuse;
}

vec3 getSpecularColor(vec3 map_specular, float light_specular, vec3 light_color, vec3 light_direction, vec3 surface_normal, vec3 view_direction) {
    if (light_specular == 0.0 || map_specular.x == 0.0) {
        return vec3(0.0);
    }

    float lambertian = max(dot(light_direction, surface_normal), 0.0);

    if (lambertian <= 0.0) {
        return vec3(0.0);
    }

    float surface_shininess = 1.0;

    vec3 reflection_direction = reflect(-light_direction, surface_normal);
    float specular_value = pow(max(dot(view_direction, reflection_direction), 0.0), surface_shininess);

    return light_color * light_specular * specular_value;
}



#endif


varying mediump vec2 var_texcoord0;
varying highp vec3 var_world_position;
varying mediump vec3 var_world_normal;
varying highp vec4 var_view_position;
varying highp vec3 var_camera_position;

void main() {
    vec4 texture_color = texture2D(DIFFUSE_TEXTURE, var_texcoord0);
    vec3 color = texture_color.rgb;
    // Defold Editor
    // if (sun_position.xyz == vec3(0)) {
    //gl_FragColor = vec4(color.rgb * vec3(0.8), 1.0);
    //  return;
    // }

    //COLOR
    vec3 illuminance_color = vec3(0);
    vec3 specular_color = vec3(0);

    vec3 surface_normal = var_world_normal;
    vec3 view_direction = normalize(var_camera_position - var_world_position);

    // Ambient
    vec3 ambient = ambient_color.rgb * ambient_color.w;
    illuminance_color = illuminance_color + ambient;

    float axis_x = lights_data.w-lights_data.z;
    float axis_y = lights_data2.y-lights_data2.x;
    float axis_z = lights_data2.w-lights_data2.z;


    highp float xStride = screen_size.x/clusters_data.x;
    highp float yStride = screen_size.y/clusters_data.y;
    highp float zStride = clusters_data.z;


    int clusterX_index = int(floor(gl_FragCoord.x/ xStride));
    int clusterY_index = int(floor(gl_FragCoord.y/ yStride));
    int clusterZ_index = int(floor(-var_view_position.z) / zStride);



    float clusterID = round(float(clusterX_index) +
    float(clusterY_index) * clusters_data.x +
    float(clusterZ_index) * clusters_data.x * clusters_data.y);

    highp int cluster_tex_idx = int(round(lights_data.x*float(LIGHT_DATA_PIXELS) + clusterID * (1.0+clusters_data.w)));
    int num_lights = int(round(rgba_to_float(getData(cluster_tex_idx))*clusters_data.w));

    for (int i = 0; i < num_lights; ++i) {
        highp int light_tex_idx = cluster_tex_idx +1 + i;
        int lightIdx = int(round(rgba_to_float(getData(light_tex_idx))*lights_data.x));
        // lightIdx = i;
       // if (num_lights!= int(lights_data.x)){
         //   gl_FragColor = vec4(1.0,0.0,0.0, 1.0);
       //     return;
      //  }
        //if (lightIdx != i){
        //    break;
       // }
        //if (lightIdx>460){
          //  gl_FragColor = vec4(1,0,0,1);
            //return;
        //}

        highp int lightIndex = lightIdx * LIGHT_DATA_PIXELS;
        float x = lights_data.z + rgba_to_float(getData(lightIndex))*axis_x;
        float y = lights_data2.x + rgba_to_float(getData(lightIndex+1))*axis_y;
        float z = lights_data2.z + rgba_to_float(getData(lightIndex+2))*axis_z;
        // vec3 spotDirection = getData(lightIndex+3).xyz;
        vec4 lightColorData = getData(lightIndex+4);
        vec4 lightData = getData(lightIndex+5);

        vec3 lightPosition = vec3(x, y, z);
        float lightRadius = lightData.x*lights_data.y;
        float lightSmoothness = lightData.y;
        float lightSpecular = lightData.z;
        float lightCutoff = lightData.w;


        float lightDistance = length(lightPosition - var_world_position);
        if (lightDistance > lightRadius) {
            // Skip this light source because of distance
            continue;
        }

        vec3 lightColor = lightColorData.rgb* lightColorData.a;
        vec3 lightDirection = normalize(lightPosition - var_world_position);
        vec3 lightIlluminanceColor = point_light2(lightColor.rgb, lightSmoothness, lightPosition, var_world_position, var_world_normal
        , lightSpecular, view_direction);



        if (lightCutoff < 1.0) {
            vec3 spotDirection = getData(lightIndex+3).xyz* 2.0 - vec3(1.0);
            float spot_theta = dot(lightDirection, normalize(spotDirection));

            float spot_cutoff = lightCutoff * 2.0 - 1.0;

            if (spot_theta <= spot_cutoff) {
                continue;
            }

            if (lightSmoothness > 0.0) {
                float spot_cutoff_inner = (spot_cutoff + 1.0) * (1.0 - lightSmoothness) - 1.0;
                float spot_epsilon = spot_cutoff_inner - spot_cutoff;
                float spot_intensity = clamp((spot_cutoff - spot_theta) / spot_epsilon, 0.0, 1.0);

                lightIlluminanceColor = lightIlluminanceColor * spot_intensity;;
            }
        }

        illuminance_color = illuminance_color + lightIlluminanceColor;

        //
    }


    //REGION SHADOW -----------------
    // shadow map
    vec4 depth_proj = var_texcoord0_shadow / var_texcoord0_shadow.w;
    float shadow = shadow_calculation(depth_proj.xyzw);
    vec3 shadow_color = shadow_color.xyz*shadow_color.w*(sunlight_color.w) * shadow;

    vec3 diff_light = vec3(0);
    diff_light += max(direct_light(sunlight_color.rgb, sun_position.xyz, var_world_position.xyz, var_world_normal, shadow_color)*sunlight_color.w, 0.0);
    diff_light += vec3(illuminance_color.xyz);

    color.rgb = color.rgb * (min(diff_light, 1.0));

    // Fog
    float dist = abs(var_view_position.z);
    float fog_max = fog.y;
    float fog_min = fog.x;
    float fog_factor = clamp((fog_max - dist) / (fog_max - fog_min) + fog_color.a, 0.0, 1.0);
    color = mix(fog_color.rgb, color, fog_factor);


    gl_FragColor = vec4(color, texture_color.a);

    //float colorz = floor(-var_view_position.z-camNear)/clusters_data.z;
  //  gl_FragColor = vec4(float(clusterX_index)/clusters_data.x,float(clusterY_index)/clusters_data.y,float(clusterZ_index)/1.0, texture_color.a);
   // gl_FragColor = vec4(float(clusterZ_index)/5.0,float(clusterZ_index)/5.0,float(clusterZ_index)/5.0, texture_color.a);
    //gl_FragColor = vec4(clusterZ_index/10.0,color.g,color.b, texture_color.a);
}

Ï¥ô#   
  ß                GLSL.std.450                     main      %  (  *  k  {  q  ×                   
 GL_GOOGLE_cpp_style_line_directive    GL_GOOGLE_include_directive      main         rgba_to_float(vf4;    
   rgba         shadow_calculation(vf4;      depth_data       direct_light(vf3;vf3;vf3;vf3;vf3;        light_color      light_position       position         vnormal      shadow_color         getData(i1;      index     )   point_light2(vf3;f1;vf3;vf3;vf3;f1;vf3;   "   light_color   #   power     $   light_position    %   position      &   vnormal   '   specular      (   view_dir      4   shadow    6   texel_size   	 7   _DMENGINE_GENERATED_UB_FS_0   7       shadow_params     9         A   x     L   y     V   uv    a   rgba      e   SHADOW_TEXTURE    i   depth     j   param        uv       dist         direction     ¡   n     ¦   diffuse   ¯   x    	 ±   _DMENGINE_GENERATED_UB_FS_7   ±       light_texture_data    ³         ¸   y     ¾   normalizedCoords      Ì   DATA_TEXTURE      Ò   dist      Ö   direction     Ý   d     à   reflect_dir   å   spec_dot      ê   irradiance    ð   attenuation      diffuse     texture_color       DIFFUSE_TEXTURE     var_texcoord0       color        illuminance_color     "  specular_color    #  surface_normal    %  var_world_normal      '  view_direction    (  var_camera_position   *  var_world_position    .  ambient  	 /  _DMENGINE_GENERATED_UB_FS_3   /      ambient_color     1        <  axis_x   	 =  _DMENGINE_GENERATED_UB_FS_8   =      lights_data   ?        E  axis_y   	 F  _DMENGINE_GENERATED_UB_FS_9   F      lights_data2      H        N  axis_z    T  xStride  
 U  _DMENGINE_GENERATED_UB_FS_11      U      screen_size   W       
 Z  _DMENGINE_GENERATED_UB_FS_10      Z      clusters_data     \        `  yStride   f  zStride   i  clusterX_index    k  gl_FragCoord      s  clusterY_index    z  clusterZ_index    {  var_view_position       clusterID       cluster_tex_idx   £  num_lights    ¤  param     §  param     ®  i     ·  light_tex_idx     ¼  lightIdx      ½  param     À  param     Ç  lightIndex    Ë  x     Î  param     Ñ  param     Ö  y     Û  param     Ý  param     â  z     è  param     ê  param     ï  lightColorData    ó  param     õ  lightData     ù  param     û  lightPosition        lightRadius     lightSmoothness   	  lightSpecular       lightCutoff     lightDistance       lightColor       lightDirection    %  lightIlluminanceColor     &  param     (  param     *  param     ,  param     .  param     0  param     2  param     9  spotDirection     =  param     C  spot_theta    H  spot_cutoff   V  spot_cutoff_inner     ]  spot_epsilon      a  spot_intensity    p  depth_proj    q  var_texcoord0_shadow      w  shadow    x  param     {  shadow_color     	 |  _DMENGINE_GENERATED_UB_FS_1   |      shadow_color      ~       	   _DMENGINE_GENERATED_UB_FS_4         sunlight_color              diff_light   	   _DMENGINE_GENERATED_UB_FS_2         sun_position                param       param       param       param       param     ³  dist      ·  fog_max  	 ¸  _DMENGINE_GENERATED_UB_FS_6   ¸      fog   º        ½  fog_min   À  fog_factor   	 È  _DMENGINE_GENERATED_UB_FS_5   È      fog_color     Ê        ×  _DMENGINE_GENERATED_gl_FragColor_0  H  7           H  7       #       G  7      G  9   "      G  9   !      G  ?       G  @       G  e   "      G  e   !      G  r       H  ±       #       G  ±      G  ³   "      G  ³   !   
   G  Ì   "      G  Ì   !      G        G    "      G    !       G        G        G          G        G        G  %      G  %        G  &      G  (        G  *        H  /          H  /      #       G  /     G  1  "      G  1  !      G  3      G  4      G  7      G  8      H  =      #       G  =     G  ?  "      G  ?  !      H  F      #       G  F     G  H  "      G  H  !      H  U      #       G  U     G  W  "      G  W  !      H  Z      #       G  Z     G  \  "      G  \  !      G  k        G  {        G  /      G  q         H  |          H  |      #       G  |     G  ~  "      G  ~  !      G        G        G        G        H            H        #       G       G    "      G    !      G        G        H        #       G       G    "      G    !      G        G        G        G  ¡      H  ¸      #       G  ¸     G  º  "      G  º  !   	   H  È          H  È      #       G  È     G  Ê  "      G  Ê  !      G  Ì      G  Ð      G  Ñ      G  ×              !                                        !  	                                !                                               !                        ! 
 !                             +     ,     ?+     -   ;+     .   7+     /   3,     0   ,   -   .   /   +     5         7         8      7   ;  8   9      +     :         ;           +  ;   <          =         +     B   ÿÿÿÿ+     I        J     T            U      T    	 b                              c   b      d       c   ;  d   e       +  ;   m      +  ;   p      +     }     A+           À+           A,              5     ±         ²      ±   ;  ²   ³      +     Ä      ?   Ç         ;  d   Ì       +     î   ÍÌL=+     õ      @+         A;  d                 T   ;         ,     !  5   5   5      $        ;  $  %     ;  $  (     ;  $  *       /        0     /  ;  0  1     +  ;   5       =        >     =  ;  >  ?       F        G     F  ;  G  H       U        V     U  ;  V  W       Z        [     Z  ;  [  \        j        ;  j  k        l        ;  j  {     +         À@+     É     +     æ     +     ñ     +     ÷     +     ;     ,     A  ,   ,   ,   ;  j  q       |        }     |  ;  }  ~                      ;                          ;           ¸        ¹     ¸  ;  ¹  º       È        É     È  ;  É  Ê        Ö        ;  Ö  ×     6               ø     ;          ;          ;           ;     "     ;     #     ;     '     ;     .     ;      <     ;      E     ;      N     ;      T     ;      `     ;      f     ;     i     ;     s     ;     z     ;           ;          ;     £     ;     ¤     ;     §     ;     ®     ;     ·     ;     ¼     ;     ½     ;     À     ;     Ç     ;      Ë     ;     Î     ;     Ñ     ;      Ö     ;     Û     ;     Ý     ;      â     ;     è     ;     ê     ;     ï     ;     ó     ;     õ     ;     ù     ;     û     ;            ;           ;      	     ;           ;           ;          ;           ;     %     ;     &     ;      (     ;     *     ;     ,     ;     .     ;      0     ;     2     ;     9     ;     =     ;      C     ;      H     ;      V     ;      ]     ;      a     ;     p     ;      w     ;     x     ;     {     ;          ;          ;          ;          ;          ;          ;      ³     ;      ·     ;      ½     ;      À     =  c       =  T       W           >      =         O                     >      >     !  >  "  !  =     &  %  >  #  &  =     )  (  =     +  *       ,  )  +       -     E   ,  >  '  -  A  Ç   2  1  :   =     3  2  O     4  3  3            A  =   6  1  :   5  =     7  6       8  4  7  >  .  8  =     9     =     :  .       ;  9  :  >     ;  A  =   @  ?  :   5  =     A  @  A  =   B  ?  :   m   =     C  B       D  A  C  >  <  D  A  =   I  H  :   p   =     J  I  A  =   K  H  :   <   =     L  K       M  J  L  >  E  M  A  =   O  H  :   5  =     P  O  A  =   Q  H  :   m   =     R  Q       S  P  R  >  N  S  A  =   X  W  :   <   =     Y  X  A  =   ]  \  :   <   =     ^  ]       _  Y  ^  >  T  _  A  =   a  W  :   p   =     b  a  A  =   c  \  :   p   =     d  c       e  b  d  >  `  e  A  =   g  \  :   m   =     h  g  >  f  h  A  l  m  k  <   =     n  m  =     o  T       p  n  o       q        p  n     r  q  >  i  r  A  l  t  k  p   =     u  t  =     v  `       w  u  v       x        w  n     y  x  >  s  y  A  l  |  {  m   =     }  |       ~  }               ~  =       f             n         >  z    =       i  o         =       s  o         A  =     \  :   <   =                               =       z  o         A  =     \  :   <   =                    A  =     \  :   p   =                                              >      A  =     ?  :   <   =                    =         A  =     \  :   5  =                ,                                 ¡           n     ¢  ¡  >    ¢  =     ¥    >  ¤  ¥  9     ¦     ¤  >  §  ¦  9     ¨     §  A  =   ©  \  :   5  =     ª  ©       «  ¨  ª       ¬        «  n     ­  ¬  >  £  ­  >  ®  :   ù  ¯  ø  ¯  ö  ±  ²      ù  ³  ø  ³  =     ´  ®  =     µ  £  ±  J   ¶  ´  µ  ú  ¶  °  ±  ø  °  =     ¸         ¹  ¸  I   =     º  ®       »  ¹  º  >  ·  »  =     ¾  ·  >  ½  ¾  9     ¿     ½  >  À  ¿  9     Á     À  A  =   Â  ?  :   <   =     Ã  Â       Ä  Á  Ã       Å        Ä  n     Æ  Å  >  ¼  Æ  =     È  ¼       Ê  È  É  >  Ç  Ê  A  =   Ì  ?  :   m   =     Í  Ì  =     Ï  Ç  >  Î  Ï  9     Ð     Î  >  Ñ  Ð  9     Ò     Ñ  =     Ó  <       Ô  Ò  Ó       Õ  Í  Ô  >  Ë  Õ  A  =   ×  H  :   <   =     Ø  ×  =     Ù  Ç       Ú  Ù  I   >  Û  Ú  9     Ü     Û  >  Ý  Ü  9     Þ     Ý  =     ß  E       à  Þ  ß       á  Ø  à  >  Ö  á  A  =   ã  H  :   m   =     ä  ã  =     å  Ç       ç  å  æ  >  è  ç  9     é     è  >  ê  é  9     ë     ê  =     ì  N       í  ë  ì       î  ä  í  >  â  î  =     ð  Ç       ò  ð  ñ  >  ó  ò  9     ô     ó  >  ï  ô  =     ö  Ç       ø  ö  ÷  >  ù  ø  9     ú     ù  >  õ  ú  =     ü  Ë  =     ý  Ö  =     þ  â  P     ÿ  ü  ý  þ  >  û  ÿ  A        õ  <   =         A  =     ?  :   p   =                    >       A        õ  p   =         >      A      
  õ  m   =       
  >  	    A        õ  5  =         >      =       û  =       *                       B     >      =         =          º  J         ÷        ú        ø    ù  ²  ø    =       ï  O                     A        ï  5  =                    >      =     !  û  =     "  *       #  !  "       $     E   #  >     $  =     '    >  &  '  =     )    >  (  )  =     +  û  >  *  +  =     -  *  >  ,  -  =     /  %  >  .  /  =     1  	  >  0  1  =     3  '  >  2  3  9     4  )   &  (  *  ,  .  0  2  >  %  4  =     5    ¸  J   6  5  ,   ÷  8      ú  6  7  8  ø  7  =     :  Ç       <  :  ;  >  =  <  9     >     =  O     ?  >  >                 @  ?  õ        B  @  A  >  9  B  =     D     =     E  9       F     E   E       G  D  F  >  C  G  =     I         J  I  õ        K  J  ,   >  H  K  =     L  C  =     M  H  ¼  J   N  L  M  ÷  P      ú  N  O  P  ø  O  ù  ²  ø  P  =     R    º  J   S  R  5   ÷  U      ú  S  T  U  ø  T  =     W  H       X  W  ,   =     Y         Z  ,   Y       [  X  Z       \  [  ,   >  V  \  =     ^  V  =     _  H       `  ^  _  >  ]  `  =     b  H  =     c  C       d  b  c  =     e  ]       f  d  e       g     +   f  5   ,   >  a  g  =     h  %  =     i  a       j  h  i  >  %  j  ù  U  ø  U  ù  8  ø  8  =     k     =     l  %       m  k  l  >     m  ù  ²  ø  ²  =     n  ®       o  n  I   >  ®  o  ù  ¯  ø  ±  =     r  q  A  l  s  q  5  =     t  s  P     u  t  t  t  t       v  r  u  >  p  v  =     y  p  >  x  y  9     z     x  >  w  z  A  Ç     ~  :   =         O                     A  =     ~  :   5  =                    A  =       :   5  =                    =       w             >  {    >    !  A  Ç       :   =         O                     >      A  Ç       :   =         O                     >      =       *  >      =       %  >      =       {  >      9 	                   A  =        :   5  =     ¡          ¢    ¡  P     £  5   5   5        ¤     (   ¢  £  =     ¥         ¦  ¥  ¤  >    ¦  =     §     Q     ¨  §      Q     ©  §     Q     ª  §     P     «  ¨  ©  ª  =     ¬         ­  ¬  «  >    ­  =     ®    =     ¯    P     °  ,   ,   ,        ±     %   ¯  °       ²  ®  ±  >    ²  A  l  ´  {  m   =     µ  ´       ¶        µ  >  ³  ¶  A  =   »  º  :   p   =     ¼  »  >  ·  ¼  A  =   ¾  º  :   <   =     ¿  ¾  >  ½  ¿  =     Á  ·  =     Â  ³       Ã  Á  Â  =     Ä  ·  =     Å  ½       Æ  Ä  Å       Ç  Ã  Æ  A  =   Ë  Ê  :   5  =     Ì  Ë       Í  Ç  Ì       Î     +   Í  5   ,   >  À  Î  A  Ç   Ï  Ê  :   =     Ð  Ï  O     Ñ  Ð  Ð            =     Ò    =     Ó  À  P     Ô  Ó  Ó  Ó       Õ     .   Ñ  Ò  Ô  >    Õ  =     Ø    A      Ù    5  =     Ú  Ù  Q     Û  Ø      Q     Ü  Ø     Q     Ý  Ø     P     Þ  Û  Ü  Ý  Ú  >  ×  Þ  ý  8  6            	   7     
   ø     =     +   
        1   +   0   þ  1   8  6            	   7        ø     ;      4      ;      6      ;     A      ;     L      ;  U   V      ;     a      ;      i      ;     j      ;  U         >  4   5   A  =   >   9   :   <   =     ?   >        @   ,   ?   >  6   @   >  A   B   ù  C   ø  C   ö  E   F       ù  G   ø  G   =     H   A   ³  J   K   H   I   ú  K   D   E   ø  D   >  L   B   ù  M   ø  M   ö  O   P       ù  Q   ø  Q   =     R   L   ³  J   S   R   I   ú  S   N   O   ø  N   =     W      O  T   X   W   W          =     Y   A   o     Z   Y   =     [   L   o     \   [   P  T   ]   Z   \   =     ^   6     T   _   ]   ^     T   `   X   _   >  V   `   =  c   f   e   =  T   g   V   W     h   f   g   >  a   h   =     k   a   >  j   k   9     l      j   >  i   l   A      n      m   =     o   n   A  =   q   9   :   p   =     r   q        s   o   r   =     t   i   º  J   u   s   t   ©     v   u   ,   5   =     w   4        x   w   v   >  4   x   ù  P   ø  P   =     y   L        z   y   I   >  L   z   ù  M   ø  O   ù  F   ø  F   =     {   A        |   {   I   >  A   |   ù  C   ø  E   =     ~   4           ~   }   >  4      =           O  T                   >        A            <   =           ¸  J         5   ÷         ú           ø     >  4   5   ù     ø     A            <   =           º  J         ,   ÷         ú           ø     >  4   5   ù     ø     A            p   =           ¸  J         5   ÷         ú           ø     >  4   5   ù     ø     A            p   =           º  J         ,   ÷         ú           ø     >  4   5   ù     ø     =        4   þ     8  6               7        7        7        7        7        ø     ;           ;           ;      ¡      ;     ¦      >        =                       E      >         =     ¢      =     £           ¤   ¢   £        ¥      (   ¤   5   >  ¡   ¥   =     §      =     ¨           ©   §   ¨   =     ª   ¡        «   ©   ª   >  ¦   «   =     ¬   ¦   þ  ¬   8  6               7        ø     ;     ¯      ;     ¸      ;  U   ¾      =     °      A  =   ´   ³   :   <   =     µ   ´   n     ¶   µ        ·   °   ¶   >  ¯   ·   =     ¹      A  =   º   ³   :   <   =     »   º   n     ¼   »        ½   ¹   ¼   >  ¸   ½   =     ¿   ¯   o     À   ¿   =     Á   ¸   o     Â   Á   P  T   Ã   À   Â   P  T   Å   Ä   Ä     T   Æ   Ã   Å   A  Ç   È   ³   :   =     É   È   O  T   Ê   É   É            T   Ë   Æ   Ê   >  ¾   Ë   =  c   Í   Ì   =  T   Î   ¾   W     Ï   Í   Î   þ  Ï   8  6     )       !   7     "   7      #   7     $   7     %   7     &   7      '   7     (   ø  *   ;     Ò      ;     Ö      ;      Ý      ;     à      ;      å      ;      ê      ;      ð      ;           =     Ó   $   =     Ô   %        Õ   Ó   Ô   >  Ò   Õ   =     ×   Ò        Ø      E   ×   Q     Ù   Ø       Q     Ú   Ø      Q     Û   Ø      P     Ü   Ù   Ú   Û   >  Ö   Ü   =     Þ   Ò        ß      B   Þ   >  Ý   ß   =     á   Ö        â   á   =     ã   &        ä      G   â   ã   >  à   ä   =     æ   à   =     ç   (        è   æ   ç        é      (   è   5   >  å   é   =     ë   &   =     ì   Ö        í   ë   ì        ï      (   í   î   >  ê   ï   =     ñ   Ý   =     ò   #        ó   ñ   ò        ô   ,   ó   =     ö   Ý        ÷   õ   ö   =     ø   Ý        ù   ÷   ø   =     ú   #        û   ù   ú   =     ü   #        ý   û   ü        þ   ô   ý        ÿ   ,   þ   >  ð   ÿ   =       "   =       ê              =       ð              >       =       ê   =       ð              =     	  '        
    	  =       å                           
    =       "              =                     >       =          þ    8  "F
DIFFUSE_TEXTURE¾Õá«Î 
DIFFUSE_TEXTURE¾Õá«Î
  
( 08 "O
_DMENGINE_GENERATED_UB_FS_0ïå®ÜçÊ»
shadow_params­òâ©­¤ð+  ( 08"O
_DMENGINE_GENERATED_UB_FS_1¹°ûÈ·Ð
shadow_color«­ñ¥¨Ï¸ö  ( 08"B
SHADOW_TEXTUREæóìðïóÂ~
SHADOW_TEXTUREæóìðïóÂ~
  
( 08"@
DATA_TEXTUREÙö¤¾
DATA_TEXTUREÙö¤¾
  
( 08"P
_DMENGINE_GENERATED_UB_FS_3åßãùöß
ambient_colorÂÔ÷ê®Í¤¿  ( 08"P
_DMENGINE_GENERATED_UB_FS_4¥¿°¿õÒ*
sunlight_coloröâöî¨ûäÚ  ( 08"J
_DMENGINE_GENERATED_UB_FS_5§âðêø°*
	fog_colorÃ°ò³L  ( 08"F
_DMENGINE_GENERATED_UB_FS_6êá±Èú
fogÄðµªöÉ  ( 08	"S
_DMENGINE_GENERATED_UB_FS_7¢´ËÐõåàü!"
light_texture_dataì°Ç§¾Ð  ( 08
"N
_DMENGINE_GENERATED_UB_FS_8àÎ³ó²î«
lights_dataëÕïðÊÕÈ  ( 08"N
_DMENGINE_GENERATED_UB_FS_9É ÊªÄäÃ
lights_data2ù¤¬°µª  ( 08"O
_DMENGINE_GENERATED_UB_FS_10ÏüÊ½
clusters_data³®ÐïÖ·ÁýO  ( 08"N
_DMENGINE_GENERATED_UB_FS_11¨ÂéÆöÉó~
screen_sizeø×ÔÛéÚ¦  ( 08*&
var_texcoord0_shadow´¥×@( 0 *
var_texcoord0ñÑñ¢ÖÀã( 0*%
var_world_positionÃ³øòÂæ¾( 0*"
var_world_normalù¥÷ºµ´8( 0*#
var_view_positionéþÝÁ¢î¨( 0*&
var_camera_positionÓòÖýÅäý§( 024
"_DMENGINE_GENERATED_gl_FragColor_0°­ùøþòïr( 0  